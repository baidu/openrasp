<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <style>
      body {
        background: black;
        color: rgb(80, 80, 80);
      }
      body,
      pre,
      #legend span {
        font-family: Menlo, monospace;
        font-weight: bold;
      }
      #topbar {
        background: black;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 42px;
        border-bottom: 1px solid rgb(80, 80, 80);
      }
      #content {
        margin-top: 50px;
      }
      #nav,
      #legend {
        float: left;
        margin-left: 10px;
      }
      #legend {
        margin-top: 12px;
      }
      #nav {
        margin-top: 10px;
      }
      #legend span {
        margin: 0 5px;
      }
      .cov0 {
        color: rgb(192, 0, 0);
      }
      .cov1 {
        color: rgb(128, 128, 128);
      }
      .cov2 {
        color: rgb(116, 140, 131);
      }
      .cov3 {
        color: rgb(104, 152, 134);
      }
      .cov4 {
        color: rgb(92, 164, 137);
      }
      .cov5 {
        color: rgb(80, 176, 140);
      }
      .cov6 {
        color: rgb(68, 188, 143);
      }
      .cov7 {
        color: rgb(56, 200, 146);
      }
      .cov8 {
        color: rgb(44, 212, 149);
      }
      .cov9 {
        color: rgb(32, 224, 152);
      }
      .cov10 {
        color: rgb(20, 236, 155);
      }
    </style>
  </head>
  <body>
    <div id="topbar">
      <div id="nav">
        <select id="files">
          <option value="file0">rasp-cloud/conf/config.go (100.0%)</option>

          <option value="file1">
            rasp-cloud/controllers/agent/agent_logs/attack_alarm.go (100.0%)
          </option>

          <option value="file2">
            rasp-cloud/controllers/agent/agent_logs/error_alarm.go (100.0%)
          </option>

          <option value="file3">
            rasp-cloud/controllers/agent/agent_logs/policy_alarm.go (100.0%)
          </option>

          <option value="file4">
            rasp-cloud/controllers/agent/heartbeat.go (100.0%)
          </option>

          <option value="file5">
            rasp-cloud/controllers/agent/rasp.go (100.0%)
          </option>

          <option value="file6">
            rasp-cloud/controllers/agent/report.go (100.0%)
          </option>

          <option value="file7">
            rasp-cloud/controllers/api/app.go (99.4%)
          </option>

          <option value="file8">
            rasp-cloud/controllers/api/fore_logs/attack_alarm.go (97.9%)
          </option>

          <option value="file9">
            rasp-cloud/controllers/api/fore_logs/error_alarm.go (93.3%)
          </option>

          <option value="file10">
            rasp-cloud/controllers/api/fore_logs/policy_alarm.go (93.3%)
          </option>

          <option value="file11">
            rasp-cloud/controllers/api/operation.go (100.0%)
          </option>

          <option value="file12">
            rasp-cloud/controllers/api/plugin.go (98.8%)
          </option>

          <option value="file13">
            rasp-cloud/controllers/api/rasp.go (95.5%)
          </option>

          <option value="file14">
            rasp-cloud/controllers/api/report.go (100.0%)
          </option>

          <option value="file15">
            rasp-cloud/controllers/api/server.go (100.0%)
          </option>

          <option value="file16">
            rasp-cloud/controllers/api/token.go (100.0%)
          </option>

          <option value="file17">
            rasp-cloud/controllers/api/user.go (97.1%)
          </option>

          <option value="file18">rasp-cloud/controllers/base.go (95.7%)</option>

          <option value="file19">
            rasp-cloud/controllers/error.go (100.0%)
          </option>

          <option value="file20">
            rasp-cloud/controllers/ping.go (100.0%)
          </option>

          <option value="file21">
            rasp-cloud/environment/environment.go (73.8%)
          </option>

          <option value="file22">rasp-cloud/es/es.go (81.2%)</option>

          <option value="file23">rasp-cloud/es/template.go (83.3%)</option>

          <option value="file24">rasp-cloud/models/app.go (87.6%)</option>

          <option value="file25">rasp-cloud/models/cookie.go (92.3%)</option>

          <option value="file26">
            rasp-cloud/models/logs/attack_alarm.go (92.2%)
          </option>

          <option value="file27">
            rasp-cloud/models/logs/error_alarm.go (80.0%)
          </option>

          <option value="file28">
            rasp-cloud/models/logs/log_handle.go (79.2%)
          </option>

          <option value="file29">
            rasp-cloud/models/logs/policy_alarm.go (88.0%)
          </option>

          <option value="file30">rasp-cloud/models/operation.go (94.9%)</option>

          <option value="file31">rasp-cloud/models/plugin.go (88.3%)</option>

          <option value="file32">rasp-cloud/models/rasp.go (79.8%)</option>

          <option value="file33">rasp-cloud/models/report.go (92.3%)</option>

          <option value="file34">rasp-cloud/models/server.go (80.0%)</option>

          <option value="file35">rasp-cloud/models/token.go (100.0%)</option>

          <option value="file36">rasp-cloud/models/user.go (75.7%)</option>

          <option value="file37">rasp-cloud/mongo/mongo.go (94.4%)</option>

          <option value="file38">
            rasp-cloud/routers/commentsRouter_controllers.go (100.0%)
          </option>

          <option value="file39">
            rasp-cloud/routers/commentsRouter_controllers_agent.go (100.0%)
          </option>

          <option value="file40">
            rasp-cloud/routers/commentsRouter_controllers_agent_agent_logs.go
            (100.0%)
          </option>

          <option value="file41">
            rasp-cloud/routers/commentsRouter_controllers_api.go (100.0%)
          </option>

          <option value="file42">
            rasp-cloud/routers/commentsRouter_controllers_api_fore_logs.go
            (100.0%)
          </option>

          <option value="file43">rasp-cloud/routers/router.go (82.4%)</option>

          <option value="file44">
            rasp-cloud/tests/inits/inits.go (100.0%)
          </option>

          <option value="file45">
            rasp-cloud/tests/start/start.go (90.0%)
          </option>

          <option value="file46">rasp-cloud/tools/email.go (14.3%)</option>

          <option value="file47">rasp-cloud/tools/error.go (100.0%)</option>

          <option value="file48">rasp-cloud/tools/file.go (72.7%)</option>

          <option value="file49">
            rasp-cloud/tools/file_logger.go (77.0%)
          </option>
        </select>
      </div>
      <div id="legend">
        <span>not tracked</span>

        <span class="cov0">not covered</span>
        <span class="cov8">covered</span>
      </div>
    </div>
    <div id="content">
      <pre
        class="file"
        id="file0"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package conf

import (
        "rasp-cloud/tools"
        "github.com/astaxie/beego"
)

const (
        StartTypeForeground = "panel"
        StartTypeAgent      = "agent"
        StartTypeReset      = "reset"
        StartTypeDefault    = "default"
)

type RaspAppConfig struct {
        EsAddr                string
        EsUser                string
        EsPwd                 string
        MongoDBAddr           string
        MongoDBUser           string
        MongoDBPwd            string
        MongoDBName           string
        MongoDBPoolLimit      int
        MaxPlugins            int
        AlarmLogMode          string
        AlarmBufferSize       int
        AlarmCheckInterval    int64
        CookieLifeTime        int
        RegisterCallbackUrl   string
        RegisterCallbackToken string
        Flag                  *Flag
}

type Flag struct {
        StartType *string
        Password  *string
        Daemon    *bool
        Version   *bool
}

var (
        AppConfig = &amp;RaspAppConfig{}
)

func InitConfig(startFlag *Flag) <span class="cov8" title="1">{
        AppConfig.Flag = startFlag
        AppConfig.EsAddr = beego.AppConfig.String("EsAddr")
        AppConfig.EsUser = beego.AppConfig.DefaultString("EsUser", "")
        AppConfig.EsPwd = beego.AppConfig.DefaultString("EsPwd", "")
        AppConfig.MongoDBAddr = beego.AppConfig.DefaultString("MongoDBAddr", "")
        AppConfig.MongoDBPoolLimit = beego.AppConfig.DefaultInt("MongoDBPoolLimit", 1024)
        AppConfig.MongoDBName = beego.AppConfig.DefaultString("MongoDBName", "openrasp")
        AppConfig.MongoDBUser = beego.AppConfig.DefaultString("MongoDBUser", "")
        AppConfig.MongoDBPwd = beego.AppConfig.DefaultString("MongoDBPwd", "")
        AppConfig.MaxPlugins = beego.AppConfig.DefaultInt("MaxPlugins", 30)
        AppConfig.AlarmLogMode = beego.AppConfig.DefaultString("AlarmLogMode", "file")
        AppConfig.AlarmBufferSize = beego.AppConfig.DefaultInt("AlarmBufferSize", 300)
        AppConfig.AlarmCheckInterval = beego.AppConfig.DefaultInt64("AlarmCheckInterval", 120)
        AppConfig.CookieLifeTime = beego.AppConfig.DefaultInt("CookieLifeTime", 7*24)
        AppConfig.RegisterCallbackUrl = beego.AppConfig.DefaultString("RegisterCallbackUrl", "")
        AppConfig.RegisterCallbackToken = beego.AppConfig.DefaultString("RegisterCallbackToken", "")
        ValidRaspConf(AppConfig)
}</span>

func ValidRaspConf(config *RaspAppConfig) <span class="cov8" title="1">{
        if config.EsAddr == "" </span><span class="cov8" title="1">{
                failLoadConfig("the 'EsAddr' config item in app.conf can not be empty")
        }</span>
        <span class="cov8" title="1">if config.MongoDBAddr == "" </span><span class="cov8" title="1">{
                failLoadConfig("the 'MongoDBAddr' config item in app.conf can not be empty")
        }</span>

        <span class="cov8" title="1">if config.MongoDBPoolLimit &lt;= 0 </span><span class="cov8" title="1">{
                failLoadConfig("the 'poolLimit' config must be greater than 0")
        }</span> else<span class="cov8" title="1"> if config.MongoDBPoolLimit &lt; 10 </span><span class="cov8" title="1">{
                beego.Warning("the value of 'poolLimit' config is less than 10, it will be set to 10")
                config.MongoDBPoolLimit = 10
        }</span>

        <span class="cov8" title="1">if config.MaxPlugins &lt;= 0 </span><span class="cov8" title="1">{
                failLoadConfig("the 'MaxPlugins' config must be greater than 0")
        }</span> else<span class="cov8" title="1"> if config.MaxPlugins &lt; 10 </span><span class="cov8" title="1">{
                beego.Warning("the value of 'MaxPlugins' config is less than 10, it will be set to 10")
                config.MaxPlugins = 10
        }</span>

        <span class="cov8" title="1">if config.AlarmBufferSize &lt;= 0 </span><span class="cov8" title="1">{
                failLoadConfig("the 'AlarmBufferSize' config must be greater than 0")
        }</span> else<span class="cov8" title="1"> if config.AlarmBufferSize &lt; 100 </span><span class="cov8" title="1">{
                beego.Warning("the value of 'AlarmBufferSize' config is less than 100, it will be set to 100")
                config.AlarmBufferSize = 100
        }</span>
        <span class="cov8" title="1">if config.AlarmCheckInterval &lt;= 0 </span><span class="cov8" title="1">{
                failLoadConfig("the 'AlarmCheckInterval' config must be greater than 0")
        }</span> else<span class="cov8" title="1"> if config.AlarmCheckInterval &lt; 10 </span><span class="cov8" title="1">{
                beego.Warning("the value of 'AlarmCheckInterval' config is less than 10, it will be set to 10")
                config.AlarmCheckInterval = 10
        }</span>
        <span class="cov8" title="1">if config.CookieLifeTime &lt;= 0 </span><span class="cov8" title="1">{
                failLoadConfig("the 'CookieLifeTime' config must be greater than 0")
        }</span>
}

func failLoadConfig(msg string) <span class="cov8" title="1">{
        tools.Panic(tools.ErrCodeConfigInitFailed, msg, nil)
}</span>
</pre>

      <pre
        class="file"
        id="file1"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package agent_logs

import (
        "rasp-cloud/controllers"
        "rasp-cloud/models/logs"
        "time"
)

// Operations about attack alarm message
type AttackAlarmController struct {
        controllers.BaseController
}

// @router / [post]
func (o *AttackAlarmController) Post() <span class="cov8" title="1">{
        var alarms []map[string]interface{}
        o.UnmarshalJson(&amp;alarms)

        count := 0
        for _, alarm := range alarms </span><span class="cov8" title="1">{
                alarm["@timestamp"] = time.Now().UnixNano() / 1000000
                err := logs.AddAttackAlarm(alarm)
                if err == nil </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">o.Serve(map[string]uint64{"count": uint64(count)})</span>
}
</pre>

      <pre
        class="file"
        id="file2"
        style="display: none"
      >//Copyright 2017-2018 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package agent_logs

import (
        "rasp-cloud/controllers"
        "rasp-cloud/models/logs"
        "time"
)

type ErrorController struct {
        controllers.BaseController
}

// @router / [post]
func (o *ErrorController) Post() <span class="cov8" title="1">{
        var alarms []map[string]interface{}
        o.UnmarshalJson(&amp;alarms)
        count := 0
        for _, alarm := range alarms </span><span class="cov8" title="1">{
                alarm["@timestamp"] = time.Now().UnixNano() / 1000000
                err := logs.AddErrorAlarm(alarm)
                if err == nil </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">o.Serve(map[string]uint64{"count": uint64(count)})</span>
}
</pre>

      <pre
        class="file"
        id="file3"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package agent_logs

import (
        "rasp-cloud/controllers"
        "rasp-cloud/models/logs"
        "time"
)

// Operations about policy alarm message
type PolicyAlarmController struct {
        controllers.BaseController
}

// @router / [post]
func (o *PolicyAlarmController) Post() <span class="cov8" title="1">{
        var alarms []map[string]interface{}
        o.UnmarshalJson(&amp;alarms)
        count := 0
        for _, alarm := range alarms </span><span class="cov8" title="1">{
                alarm["@timestamp"] = time.Now().UnixNano() / 1000000
                err := logs.AddPolicyAlarm(alarm)
                if err == nil </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">o.Serve(map[string]uint64{"count": uint64(count)})</span>
}
</pre>

      <pre
        class="file"
        id="file4"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package agent

import (
        "gopkg.in/mgo.v2"
        "net/http"
        "rasp-cloud/controllers"
        "rasp-cloud/models"
        "time"
)

// Operations about plugin
type HeartbeatController struct {
        controllers.BaseController
}

type heartbeatParam struct {
        RaspId        string `json:"rasp_id"`
        PluginVersion string `json:"plugin_version"`
        PluginMd5     string `json:"plugin_md5"`
        ConfigTime    int64  `json:"config_time"`
}

// @router / [post]
func (o *HeartbeatController) Post() <span class="cov8" title="1">{
        var heartbeat heartbeatParam
        o.UnmarshalJson(&amp;heartbeat)
        rasp, err := models.GetRaspById(heartbeat.RaspId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get rasp", err)
        }</span>
        <span class="cov8" title="1">rasp.LastHeartbeatTime = time.Now().Unix()
        rasp.PluginVersion = heartbeat.PluginVersion
        err = models.UpsertRaspById(heartbeat.RaspId, rasp)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to update rasp", err)
        }</span>
        <span class="cov8" title="1">pluginMd5 := heartbeat.PluginMd5
        configTime := heartbeat.ConfigTime
        appId := o.Ctx.Input.Header("X-OpenRASP-AppID")
        app, err := models.GetAppById(appId)
        if err != nil || app == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "cannot get the app", err)
        }</span>

        <span class="cov8" title="1">result := make(map[string]interface{})
        isUpdate := false
        // handle plugin
        selectedPlugin, err := models.GetSelectedPlugin(appId, true)
        if err != nil &amp;&amp; err != mgo.ErrNotFound </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get selected plugin", err)
        }</span>
        <span class="cov8" title="1">if selectedPlugin != nil </span><span class="cov8" title="1">{
                if pluginMd5 != selectedPlugin.Md5 </span><span class="cov8" title="1">{
                        isUpdate = true
                }</span>
                <span class="cov8" title="1">if app.ConfigTime &gt; 0 &amp;&amp; app.ConfigTime &gt; int64(configTime) </span><span class="cov8" title="1">{
                        isUpdate = true
                }</span>
        }
        <span class="cov8" title="1">if isUpdate </span><span class="cov8" title="1">{
                whitelistConfig := make(map[string]interface{})
                for _, configItem := range app.WhitelistConfig </span><span class="cov8" title="1">{
                        whiteHookTypes := make([]string, 0, len(configItem.Hook))
                        for hookType, isWhite := range configItem.Hook </span><span class="cov8" title="1">{
                                if isWhite </span><span class="cov8" title="1">{
                                        whiteHookTypes = append(whiteHookTypes, hookType)
                                }</span>
                        }
                        <span class="cov8" title="1">whitelistConfig[configItem.Url] = whiteHookTypes</span>
                }
                //app.GeneralConfig["algorithm.config"] = selectedPlugin.AlgorithmConfig
                <span class="cov8" title="1">app.GeneralConfig["hook.white"] = whitelistConfig
                result["plugin"] = selectedPlugin
                result["config_time"] = app.ConfigTime
                result["config"] = app.GeneralConfig</span>
        }
        <span class="cov8" title="1">o.Serve(result)</span>
}
</pre>

      <pre
        class="file"
        id="file5"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package agent

import (
        "github.com/astaxie/beego/validation"
        "net/http"
        "rasp-cloud/controllers"
        "rasp-cloud/models"
        "time"
        "rasp-cloud/conf"
        "github.com/astaxie/beego"
)

type RaspController struct {
        controllers.BaseController
}

// @router / [post]
func (o *RaspController) Post() <span class="cov8" title="1">{
        var rasp = &amp;models.Rasp{}
        rasp.AppId = o.Ctx.Input.Header("X-OpenRASP-AppID")
        o.UnmarshalJson(rasp)
        if rasp.Id == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "rasp id cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(rasp.Id) &lt; 16 || len(rasp.Id) &gt; 512 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of rasp id must be between 16~512")
        }</span>
        <span class="cov8" title="1">if rasp.Version == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "rasp_version cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(rasp.Version) &gt;= 50 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of rasp version must be less than 50")
        }</span>
        <span class="cov8" title="1">if rasp.HostName == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "rasp hostname cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(rasp.HostName) &gt;= 1024 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of rasp hostname must be less than 1024")
        }</span>
        <span class="cov8" title="1">if rasp.LanguageVersion == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "rasp language_version cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(rasp.LanguageVersion) &gt;= 50 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of rasp language version must be less than 50")
        }</span>
        <span class="cov8" title="1">if rasp.Language == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "rasp language cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(rasp.Language) &gt;= 50 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of rasp language must be less than 50")
        }</span>
        <span class="cov8" title="1">if len(rasp.ServerType) &gt;= 256 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of rasp server type must be less than 256")
        }</span>
        <span class="cov8" title="1">if len(rasp.ServerVersion) &gt;= 50 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of rasp server version must be less than 50")
        }</span>
        <span class="cov8" title="1">if rasp.RegisterIp != "" </span><span class="cov8" title="1">{
                valid := validation.Validation{}
                if result := valid.IP(rasp.RegisterIp, "IP"); !result.Ok </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest, "rasp register_ip format error: "+result.Error.Message)
                }</span>
        }
        <span class="cov8" title="1">if rasp.HeartbeatInterval &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "heartbeat_interval must be greater than 0")
        }</span>

        <span class="cov8" title="1">if rasp.Environ == nil </span><span class="cov8" title="1">{
                rasp.Environ = map[string]string{}
        }</span>

        <span class="cov8" title="1">for k, v := range rasp.Environ </span><span class="cov8" title="1">{
                if len(k) &gt; 4096 </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest,
                                "the length of environ key cannot be greater than 4096")
                }</span>
                <span class="cov8" title="1">if len(v) &gt; 4096 </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest,
                                "the length of environ value cannot be greater than 4096")
                }</span>
        }

        <span class="cov8" title="1">rasp.LastHeartbeatTime = time.Now().Unix()
        rasp.RegisterTime = time.Now().Unix()
        err := models.UpsertRaspById(rasp.Id, rasp)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to add rasp", err)
        }</span>
        <span class="cov8" title="1">if len(conf.AppConfig.RegisterCallbackUrl) &gt; 0 </span><span class="cov8" title="1">{
                go func() </span><span class="cov8" title="1">{
                        err = models.RegisterCallback(conf.AppConfig.RegisterCallbackUrl, conf.AppConfig.RegisterCallbackToken, rasp)
                        if err != nil </span><span class="cov8" title="1">{
                                beego.Error("failed to send register callback to url: " +
                                        conf.AppConfig.RegisterCallbackUrl + ", " + err.Error())
                        }</span>
                }()
        }
        <span class="cov8" title="1">models.AddOperation(rasp.AppId, models.OperationTypeRegisterRasp, o.Ctx.Input.IP(),
                "New RASP agent registered from "+rasp.HostName+": "+rasp.Id, "")
        o.Serve(rasp)</span>
}
</pre>

      <pre
        class="file"
        id="file6"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package agent

import (
        "net/http"
        "rasp-cloud/controllers"
        "rasp-cloud/models"
)

type ReportController struct {
        controllers.BaseController
}

// @router / [post]
func (o *ReportController) Post() <span class="cov8" title="1">{
        var reportData *models.ReportData
        o.UnmarshalJson(&amp;reportData)
        if reportData.RaspId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "rasp_id cannot be empty")
        }</span>
        <span class="cov8" title="1">rasp, err := models.GetRaspById(reportData.RaspId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get rasp", err)
        }</span>
        <span class="cov8" title="1">if reportData.Time &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "time param must be greater than 0")
        }</span>
        <span class="cov8" title="1">if reportData.RequestSum &lt; 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "request_sum param cannot be less than 0")
        }</span>
        <span class="cov8" title="1">err = models.AddReportData(reportData, rasp.AppId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to insert report data", err)
        }</span>
        <span class="cov8" title="1">o.Serve(reportData)</span>
}
</pre>

      <pre
        class="file"
        id="file7"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package api

import (
        "encoding/json"
        "github.com/astaxie/beego/validation"
        "gopkg.in/mgo.v2"
        "gopkg.in/mgo.v2/bson"
        "math"
        "net/http"
        "rasp-cloud/controllers"
        "rasp-cloud/models"
        "strconv"
        "sync"
        "time"
)

// Operations about app
type AppController struct {
        controllers.BaseController
}

type pageParam struct {
        AppId   string `json:"app_id"`
        Page    int    `json:"page"`
        Perpage int    `json:"perpage"`
}

var (
        supportLanguages = []string{"java", "php"}
        mutex            sync.Mutex
)

// @router /get [post]
func (o *AppController) GetApp() <span class="cov8" title="1">{
        var data pageParam
        o.UnmarshalJson(&amp;data)
        if data.AppId == "" </span><span class="cov8" title="1">{
                o.ValidPage(data.Page, data.Perpage)
                var result = make(map[string]interface{})
                total, apps, err := models.GetAllApp(data.Page, data.Perpage, true)
                if err != nil </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest, "failed to get apps", err)
                }</span>
                <span class="cov8" title="1">if apps == nil </span><span class="cov8" title="1">{
                        apps = make([]*models.App, 0)
                }</span>
                <span class="cov8" title="1">result["total"] = total
                result["total_page"] = math.Ceil(float64(total) / float64(data.Perpage))
                result["page"] = data.Page
                result["perpage"] = data.Perpage
                result["data"] = apps
                o.Serve(result)</span>
        } else<span class="cov8" title="1"> {
                app, err := models.GetAppById(data.AppId)
                if err != nil </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest, "failed to get app", err)
                }</span>
                <span class="cov8" title="1">o.Serve(app)</span>
        }
}

// @router /rasp/get [post]
func (o *AppController) GetRasps() <span class="cov8" title="1">{
        var param pageParam
        o.UnmarshalJson(&amp;param)
        o.ValidPage(param.Page, param.Perpage)

        app, err := models.GetAppById(param.AppId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get app", err)
        }</span>
        <span class="cov8" title="1">if app == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the app doesn't exist")
        }</span>
        <span class="cov8" title="1">var result = make(map[string]interface{})
        total, rasps, err := models.GetRaspByAppId(app.Id, param.Page, param.Perpage)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get apps", err)
        }</span>
        <span class="cov8" title="1">if rasps == nil </span><span class="cov8" title="1">{
                rasps = make([]*models.Rasp, 0)
        }</span>
        <span class="cov8" title="1">result["total"] = total
        result["total_page"] = math.Ceil(float64(total) / float64(param.Perpage))
        result["page"] = param.Page
        result["perpage"] = param.Perpage
        result["data"] = rasps
        o.Serve(result)</span>
}

// @router /secret/get [post]
func (o *AppController) GetAppSecret() <span class="cov8" title="1">{
        var param struct {
                AppId string `json:"app_id"`
        }
        o.UnmarshalJson(&amp;param)
        if param.AppId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app_id can not be empty")
        }</span>
        <span class="cov8" title="1">secret, err := models.GetSecretByAppId(param.AppId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get secret", err)
        }</span>
        <span class="cov8" title="1">o.Serve(map[string]string{
                "secret": secret,
        })</span>
}

// @router /secret/regenerate [post]
func (o *AppController) RegenerateAppSecret() <span class="cov8" title="1">{
        var param struct {
                AppId string `json:"app_id"`
        }
        o.UnmarshalJson(&amp;param)
        if param.AppId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app_id can not be empty")
        }</span>
        <span class="cov8" title="1">secret, err := models.RegenerateSecret(param.AppId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get secret", err)
        }</span>
        <span class="cov8" title="1">models.AddOperation(param.AppId, models.OperationTypeRegenerateSecret,
                o.Ctx.Input.IP(), "Reset AppSecret of "+param.AppId)
        o.Serve(map[string]string{
                "secret": secret,
        })</span>
}

// @router /general/config [post]
func (o *AppController) UpdateAppGeneralConfig() <span class="cov8" title="1">{
        var param struct {
                AppId  string                 `json:"app_id"`
                Config map[string]interface{} `json:"config"`
        }
        o.UnmarshalJson(&amp;param)

        if param.AppId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app_id can not be empty")
        }</span>
        <span class="cov8" title="1">if param.Config == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "config can not be empty")
        }</span>
        <span class="cov8" title="1">o.validateAppConfig(param.Config)
        app, err := models.UpdateGeneralConfig(param.AppId, param.Config)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to update app general config", err)
        }</span>
        <span class="cov8" title="1">models.AddOperation(param.AppId, models.OperationTypeUpdateGenerateConfig,
                o.Ctx.Input.IP(), "Updated general config of "+param.AppId)
        o.Serve(app)</span>
}

// @router /whitelist/config [post]
func (o *AppController) UpdateAppWhiteListConfig() <span class="cov8" title="1">{
        var param struct {
                AppId  string                       `json:"app_id"`
                Config []models.WhitelistConfigItem `json:"config"`
        }
        o.UnmarshalJson(&amp;param)

        if param.AppId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app_id can not be empty")
        }</span>
        <span class="cov8" title="1">if param.Config == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "config can not be empty")
        }</span>
        <span class="cov8" title="1">o.validateWhiteListConfig(param.Config)
        app, err := models.UpdateWhiteListConfig(param.AppId, param.Config)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to update app whitelist config", err)
        }</span>
        <span class="cov8" title="1">models.AddOperation(param.AppId, models.OperationTypeUpdateWhitelistConfig,
                o.Ctx.Input.IP(), "Updated whitelist config of "+param.AppId)
        o.Serve(app)</span>
}

// @router / [post]
func (o *AppController) Post() <span class="cov8" title="1">{
        var app = &amp;models.App{}

        o.UnmarshalJson(app)

        if app.Name == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app name cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(app.Name) &gt; 64 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of app name cannot be greater than 64")
        }</span>
        <span class="cov8" title="1">if app.Language == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app programming language cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(app.Language) &gt; 64 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of app language name cannot be greater than 64")
        }</span>
        <span class="cov8" title="1">languageSupported := false
        for _, language := range supportLanguages </span><span class="cov8" title="1">{
                if app.Language == language </span><span class="cov8" title="1">{
                        languageSupported = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !languageSupported </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "Unsupported programming language: "+app.Language)
        }</span>
        <span class="cov8" title="1">if len(app.Description) &gt; 1024 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of the app description can not be greater than 1024")
        }</span>
        <span class="cov8" title="1">if len(app.SelectedPluginId) &gt; 1024 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of the app selected_plugin_id can not be greater than 1024")
        }</span>
        <span class="cov8" title="1">if app.EmailAlarmConf.Enable </span><span class="cov8" title="1">{
                o.validEmailConf(&amp;app.EmailAlarmConf)
        }</span>
        <span class="cov8" title="1">if app.HttpAlarmConf.Enable </span><span class="cov8" title="1">{
                o.validHttpAlarm(&amp;app.HttpAlarmConf)
        }</span>
        <span class="cov8" title="1">if app.DingAlarmConf.Enable </span><span class="cov8" title="1">{
                o.validDingConf(&amp;app.DingAlarmConf)
        }</span>
        <span class="cov8" title="1">if app.GeneralConfig != nil </span><span class="cov8" title="1">{
                o.validateAppConfig(app.GeneralConfig)
                configTime := time.Now().UnixNano()
                app.ConfigTime = configTime
        }</span>

        <span class="cov8" title="1">if app.WhitelistConfig != nil </span><span class="cov8" title="1">{
                o.validateWhiteListConfig(app.WhitelistConfig)
                configTime := time.Now().UnixNano()
                app.ConfigTime = configTime
        }</span> else<span class="cov8" title="1"> {
                app.WhitelistConfig = make([]models.WhitelistConfigItem, 0)
        }</span>
        <span class="cov8" title="1">app, err := models.AddApp(app)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "create app failed", err)
        }</span>
        <span class="cov8" title="1">models.AddOperation(app.Id, models.OperationTypeAddApp, o.Ctx.Input.IP(), "New app created with name "+app.Name)
        o.Serve(app)</span>
}

// @router /config [post]
func (o *AppController) ConfigApp() <span class="cov8" title="1">{
        var param struct {
                AppId       string `json:"app_id"`
                Language    string `json:"language,omitempty"`
                Name        string `json:"name,omitempty"`
                Description string `json:"description,omitempty"`
        }

        o.UnmarshalJson(&amp;param)
        if param.AppId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app_id can not be empty")
        }</span>
        <span class="cov8" title="1">_, err := models.GetAppById(param.AppId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get app", err)
        }</span>
        <span class="cov8" title="1">if param.Name == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app name cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(param.Name) &gt; 64 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of app name cannot be greater than 64")
        }</span>
        <span class="cov8" title="1">if param.Language == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app language cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(param.Language) &gt; 64 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of app language name cannot be greater than 64")
        }</span>
        <span class="cov8" title="1">languageSupported := false
        for _, language := range supportLanguages </span><span class="cov8" title="1">{
                if param.Language == language </span><span class="cov8" title="1">{
                        languageSupported = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !languageSupported </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "can not support the language: "+param.Language)
        }</span>
        <span class="cov8" title="1">if len(param.Description) &gt; 1024 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of app description can not be greater than 1024")
        }</span>
        <span class="cov8" title="1">updateData := bson.M{"name": param.Name, "language": param.Language, "description": param.Description}
        app, err := models.UpdateAppById(param.AppId, updateData)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to update app config", err)
        }</span>
        <span class="cov8" title="1">operationData, err := json.Marshal(updateData)
        models.AddOperation(app.Id, models.OperationTypeEditApp, o.Ctx.Input.IP(), "Updated app info for "+param.AppId+": "+string(operationData))
        o.Serve(app)</span>
}

func (o *AppController) validEmailConf(conf *models.EmailAlarmConf) <span class="cov8" title="1">{
        var valid = validation.Validation{}
        if conf.ServerAddr == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the email server_addr cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(conf.ServerAddr) &gt; 256 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of email server_addr cannot be greater than 256")
        }</span>
        <span class="cov8" title="1">if len(conf.From) &gt; 256 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of from cannot be greater than 256")
        }</span>
        <span class="cov8" title="1">if len(conf.Subject) &gt; 256 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of email subject cannot be greater than 256")
        }</span>
        <span class="cov8" title="1">if len(conf.UserName) &gt; 256 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of email username cannot be greater than 256")
        }</span>
        <span class="cov8" title="1">if len(conf.Password) &gt; 256 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of email password cannot be greater than 256")
        }</span>
        <span class="cov8" title="1">if len(conf.RecvAddr) == 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the email recv_addr cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(conf.RecvAddr) &gt; 128 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the count of email recv_addr cannot be greater than 128")
        }</span>
        <span class="cov8" title="1">conf.RecvAddr = o.validAppArrayParam(conf.RecvAddr, "email recv_addr", valid.Email)</span>
}

func (o *AppController) validDingConf(conf *models.DingAlarmConf) <span class="cov8" title="1">{
        if conf.CorpId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the ding ding corp_id cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(conf.CorpId) &gt; 256 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of ding ding corp_id cannot be greater than 128")
        }</span>
        <span class="cov8" title="1">if conf.CorpSecret == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the ding ding corp_secret cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(conf.CorpSecret) &gt; 256 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of ding ding corp_secret cannot be greater than 128")
        }</span>
        <span class="cov8" title="1">if len(conf.RecvParty) == 0 &amp;&amp; len(conf.RecvUser) == 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "ding ding recv_party and ding ding recv_user cannot be empty at the same time")
        }</span>
        <span class="cov8" title="1">if len(conf.RecvParty) &gt; 128 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the count of ding ding recv_party cannot be greater than 128")
        }</span>
        <span class="cov8" title="1">if len(conf.RecvUser) &gt; 128 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the count of ding ding recv_user cannot be greater than 128")
        }</span>
        <span class="cov8" title="1">if conf.AgentId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the ding ding agent_id cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(conf.AgentId) &gt; 256 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of ding agent_id cannot be greater than 256")
        }</span>
        <span class="cov8" title="1">conf.RecvUser = o.validAppArrayParam(conf.RecvUser, "ding recv_user", nil)
        conf.RecvParty = o.validAppArrayParam(conf.RecvParty, "ding recv_party", nil)</span>
}

func (o *AppController) validHttpAlarm(conf *models.HttpAlarmConf) <span class="cov8" title="1">{
        if len(conf.RecvAddr) == 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the http recv_addr cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(conf.RecvAddr) &gt; 128 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the count of http recv_addr cannot be greater than 128")
        }</span>
        <span class="cov8" title="1">conf.RecvAddr = o.validAppArrayParam(conf.RecvAddr, "http recv_addr", nil)</span>
}

// @router /delete [post]
func (o *AppController) Delete() <span class="cov8" title="1">{
        var app = &amp;models.App{}
        o.UnmarshalJson(app)

        if app.Id == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the id cannot be empty")
        }</span>
        <span class="cov8" title="1">mutex.Lock()
        defer mutex.Unlock()
        count, err := models.GetAppCount()
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get app count", err)
        }</span>
        <span class="cov8" title="1">if count &lt;= 1 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to remove app: keep at least one app")
        }</span>
        <span class="cov8" title="1">app, err = models.RemoveAppById(app.Id)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to remove app", err)
        }</span>
        <span class="cov8" title="1">err = models.RemoveRaspByAppId(app.Id)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to remove rasp by app_id", err)
        }</span>
        <span class="cov8" title="1">err = models.RemovePluginByAppId(app.Id)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to remove plugin by app_id", err)
        }</span>
        <span class="cov8" title="1">models.AddOperation(app.Id, models.OperationTypeDeleteApp, o.Ctx.Input.IP(), "Deleted app with name "+app.Name)
        o.ServeWithEmptyData()</span>
}

func (o *AppController) validAppArrayParam(param []string, paramName string,
        valid func(interface{}, string) *validation.Result) []string <span class="cov8" title="1">{
        if param != nil </span><span class="cov8" title="1">{
                for i, v := range param </span><span class="cov8" title="1">{
                        if len(v) &gt; 256 </span><span class="cov8" title="1">{
                                o.ServeError(http.StatusBadRequest,
                                        "the element's length of "+paramName+" cannot be greater than 256")
                        }</span>
                        <span class="cov8" title="1">if valid != nil </span><span class="cov8" title="1">{
                                if result := valid(v, "valid"); !result.Ok </span><span class="cov8" title="1">{
                                        o.ServeError(http.StatusBadRequest,
                                                "the "+strconv.Itoa(i)+"th element's format of "+paramName+" is error: "+result.Error.Message)
                                }</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                param = make([]string, 0)
        }</span>
        <span class="cov8" title="1">return param</span>
}

func (o *AppController) validateAppConfig(config map[string]interface{}) <span class="cov8" title="1">{
        for key, value := range config </span><span class="cov8" title="1">{
                if value == nil </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest, "the value of "+key+" config cannot be nil")
                }</span>
                <span class="cov8" title="1">if key == "" </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest,
                                "the config key can not be empty")
                }</span>
                <span class="cov8" title="1">if len(key) &gt; 512 </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest,
                                "the length of config key '"+key+"' must be less than 512")
                }</span>
                <span class="cov8" title="1">if v, ok := value.(string); ok </span><span class="cov8" title="1">{
                        if len(v) &gt;= 2048 </span><span class="cov8" title="1">{
                                o.ServeError(http.StatusBadRequest,
                                        "the value's length of config key '"+key+"' must be less than 2048")
                        }</span>
                }
        }
}

func (o *AppController) validateWhiteListConfig(config []models.WhitelistConfigItem) <span class="cov8" title="1">{
        if len(config) &gt; 200 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest,
                        "the count of whitelist config items must be between (0,200]")
        }</span>
        <span class="cov8" title="1">for _, value := range config </span><span class="cov8" title="1">{
                if len(value.Url) &gt; 200 || len(value.Url) == 0 </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest,
                                "the length of whitelist config url must be between [1,200]")
                }</span>
                <span class="cov8" title="1">for key := range value.Hook </span><span class="cov8" title="1">{
                        if len(key) &gt; 128 </span><span class="cov8" title="1">{
                                o.ServeError(http.StatusBadRequest,
                                        "the length of hook's type can not be greater 128")
                        }</span>
                }
        }
}

// @router /alarm/config [post]
func (o *AppController) ConfigAlarm() <span class="cov8" title="1">{
        var param struct {
                AppId          string                 `json:"app_id"`
                EmailAlarmConf *models.EmailAlarmConf `json:"email_alarm_conf,omitempty"`
                DingAlarmConf  *models.DingAlarmConf  `json:"ding_alarm_conf,omitempty"`
                HttpAlarmConf  *models.HttpAlarmConf  `json:"http_alarm_conf,omitempty"`
        }
        o.UnmarshalJson(&amp;param)

        if param.AppId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app_id can not be empty")
        }</span>
        <span class="cov8" title="1">app, err := models.GetAppByIdWithoutMask(param.AppId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get app", err)
        }</span>
        <span class="cov8" title="1">var updateData bson.M
        if param.EmailAlarmConf != nil </span><span class="cov8" title="1">{
                if param.EmailAlarmConf.Password == models.SecreteMask </span><span class="cov8" title="1">{
                        param.EmailAlarmConf.Password = app.EmailAlarmConf.Password
                }</span>
                <span class="cov8" title="1">o.validEmailConf(param.EmailAlarmConf)</span>
        }
        <span class="cov8" title="1">if param.HttpAlarmConf != nil </span><span class="cov8" title="1">{
                o.validHttpAlarm(param.HttpAlarmConf)
        }</span>
        <span class="cov8" title="1">if param.DingAlarmConf != nil </span><span class="cov8" title="1">{
                if param.DingAlarmConf.CorpSecret == models.SecreteMask </span><span class="cov8" title="1">{
                        param.DingAlarmConf.CorpSecret = app.DingAlarmConf.CorpSecret
                }</span>
                <span class="cov8" title="1">o.validDingConf(param.DingAlarmConf)</span>
        }
        <span class="cov8" title="1">content, err := json.Marshal(param)
        if err != nil </span><span class="cov0" title="0">{
                o.ServeError(http.StatusBadRequest, "failed to encode param to json", err)
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(content, &amp;updateData)
        if err != nil </span><span class="cov0" title="0">{
                o.ServeError(http.StatusBadRequest, "failed to decode param json", err)
        }</span>
        <span class="cov8" title="1">app, err = models.UpdateAppById(param.AppId, updateData)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to update alarm config", err)
        }</span>
        <span class="cov8" title="1">models.AddOperation(app.Id, models.OperationTypeUpdateAlarmConfig, o.Ctx.Input.IP(),
                "Alarm configuration updated for "+param.AppId)
        o.Serve(app)</span>
}

// @router /plugin/get [post]
func (o *AppController) GetPlugins() <span class="cov8" title="1">{
        var param pageParam
        o.UnmarshalJson(&amp;param)
        o.ValidPage(param.Page, param.Perpage)

        app, err := models.GetAppById(param.AppId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get app", err)
        }</span>
        <span class="cov8" title="1">if app == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the app doesn't exist")
        }</span>
        <span class="cov8" title="1">var result = make(map[string]interface{})
        total, plugins, err := models.GetPluginsByApp(param.AppId, (param.Page-1)*param.Perpage, param.Perpage)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get plugins", err)
        }</span>
        <span class="cov8" title="1">result["total"] = total
        result["total_page"] = math.Ceil(float64(total) / float64(param.Perpage))
        result["page"] = param.Page
        result["perpage"] = param.Perpage
        result["data"] = plugins
        o.Serve(result)</span>
}

// @router /plugin/select/get [post]
func (o *AppController) GetSelectedPlugin() <span class="cov8" title="1">{
        var param map[string]string
        o.UnmarshalJson(&amp;param)

        appId := param["app_id"]
        if appId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app_id cannot be empty")
        }</span>
        <span class="cov8" title="1">plugin, err := models.GetSelectedPlugin(appId, false)

        if err != nil </span><span class="cov8" title="1">{
                if mgo.ErrNotFound == err </span><span class="cov8" title="1">{
                        o.ServeWithEmptyData()
                        return
                }</span>
                <span class="cov8" title="1">o.ServeError(http.StatusBadRequest, "failed to get selected plugin", err)</span>
        }

        <span class="cov8" title="1">o.Serve(plugin)</span>
}

// @router /plugin/select [post]
func (o *AppController) SetSelectedPlugin() <span class="cov8" title="1">{
        var param map[string]string
        o.UnmarshalJson(&amp;param)
        appId := param["app_id"]
        if appId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app_id cannot be empty")
        }</span>
        <span class="cov8" title="1">pluginId := param["plugin_id"]
        if pluginId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "plugin_id cannot be empty")
        }</span>
        <span class="cov8" title="1">plugin, err := models.SetSelectedPlugin(appId, pluginId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to set selected plugin", err)
        }</span>
        <span class="cov8" title="1">models.AddOperation(appId, models.OperationTypeSetSelectedPlugin, o.Ctx.Input.IP(),
                "Deployed plugin "+plugin.Name+": "+plugin.Version+" ["+plugin.Id+"]")
        o.ServeWithEmptyData()</span>
}

// @router /email/test [post]
func (o *AppController) TestEmail() <span class="cov8" title="1">{
        var param map[string]string
        o.UnmarshalJson(&amp;param)
        appId := param["app_id"]
        if appId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app_id cannot be empty")
        }</span>
        <span class="cov8" title="1">app, err := models.GetAppByIdWithoutMask(appId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "can not find the app", err)
        }</span>
        <span class="cov8" title="1">if !app.EmailAlarmConf.Enable </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "please enable the email alarm first")
        }</span>
        <span class="cov8" title="1">err = models.PushEmailAttackAlarm(app, 0, nil, true)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to test email alarm", err)
        }</span>
        <span class="cov8" title="1">o.ServeWithEmptyData()</span>
}

// @router /ding/test [post]
func (o *AppController) TestDing(config map[string]interface{}) <span class="cov8" title="1">{
        var param map[string]string
        o.UnmarshalJson(&amp;param)
        appId := param["app_id"]
        if appId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app_id cannot be empty")
        }</span>
        <span class="cov8" title="1">app, err := models.GetAppByIdWithoutMask(appId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "can not find the app", err)
        }</span>
        <span class="cov8" title="1">if !app.DingAlarmConf.Enable </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "please enable the ding ding alarm first")
        }</span>
        <span class="cov8" title="1">err = models.PushDingAttackAlarm(app, 0, nil, true)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to test ding ding alarm", err)
        }</span>
        <span class="cov8" title="1">o.ServeWithEmptyData()</span>
}

// @router /http/test [post]
func (o *AppController) TestHttp(config map[string]interface{}) <span class="cov8" title="1">{
        var param map[string]string
        o.UnmarshalJson(&amp;param)
        appId := param["app_id"]
        if appId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app_id cannot be empty")
        }</span>
        <span class="cov8" title="1">app, err := models.GetAppByIdWithoutMask(appId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "can not find the app", err)
        }</span>
        <span class="cov8" title="1">if !app.HttpAlarmConf.Enable </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "please enable the http alarm first")
        }</span>
        <span class="cov8" title="1">err = models.PushHttpAttackAlarm(app, 0, nil, true)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to test http alarm", err)
        }</span>
        <span class="cov8" title="1">o.ServeWithEmptyData()</span>
}
</pre>

      <pre
        class="file"
        id="file8"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package fore_logs

import (
        "rasp-cloud/controllers"
        "encoding/json"
        "net/http"
        "rasp-cloud/models"
        "rasp-cloud/models/logs"
        "math"
        "time"
)

// Operations about attack alarm message
type AttackAlarmController struct {
        controllers.BaseController
}

// @router /aggr/time [post]
func (o *AttackAlarmController) AggregationWithTime() <span class="cov8" title="1">{
        var param = &amp;logs.AggrTimeParam{}
        o.UnmarshalJson(&amp;param)
        if param.AppId != "" </span><span class="cov8" title="1">{
                _, err := models.GetAppById(param.AppId)
                if err != nil </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest, "failed to get the app: "+param.AppId)
                }</span>
        } else<span class="cov8" title="1"> {
                param.AppId = "*"
        }</span>
        <span class="cov8" title="1">if param.StartTime &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time must be greater than 0")
        }</span>
        <span class="cov8" title="1">if param.EndTime &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "end_time must be greater than 0")
        }</span>
        <span class="cov8" title="1">if param.StartTime &gt; param.EndTime </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time cannot be greater than end_time")
        }</span>
        <span class="cov8" title="1">duration := time.Duration(param.EndTime-param.StartTime) * time.Millisecond
        if duration &gt; 366*24*time.Hour </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "time duration can not be greater than 366 days")
        }</span>
        <span class="cov8" title="1">if param.Interval == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "interval cannot be empty")
        }</span>
        <span class="cov8" title="1">if param.TimeZone == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "time_zone cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(param.Interval) &gt; 32 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of interval cannot be greater than 32")
        }</span>
        <span class="cov8" title="1">if len(param.TimeZone) &gt; 32 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of time_zone cannot be greater than 32")
        }</span>
        <span class="cov8" title="1">result, err :=
                logs.AggregationAttackWithTime(param.StartTime, param.EndTime, param.Interval, param.TimeZone, param.AppId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get aggregation from es", err)
        }</span>
        <span class="cov8" title="1">o.Serve(result)</span>
}

// @router /aggr/type [post]
func (o *AttackAlarmController) AggregationWithType() <span class="cov8" title="1">{
        var param = &amp;logs.AggrFieldParam{}
        o.UnmarshalJson(&amp;param)
        o.validFieldAggrParam(param)
        result, err :=
                logs.AggregationAttackWithType(param.StartTime, param.EndTime, param.Size, param.AppId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get aggregation from es", err)
        }</span>
        <span class="cov8" title="1">o.Serve(result)</span>
}

// @router /aggr/ua [post]
func (o *AttackAlarmController) AggregationWithUserAgent() <span class="cov8" title="1">{
        var param = &amp;logs.AggrFieldParam{}
        o.UnmarshalJson(&amp;param)
        o.validFieldAggrParam(param)
        result, err :=
                logs.AggregationAttackWithUserAgent(param.StartTime, param.EndTime, param.Size, param.AppId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get aggregation from es", err)
        }</span>
        <span class="cov8" title="1">o.Serve(result)</span>
}

// @router /search [post]
func (o *AttackAlarmController) Search() <span class="cov8" title="1">{
        param, searchData := o.handleAttackSearchParam()
        total, result, err := logs.SearchLogs(param.Data.StartTime, param.Data.EndTime,
                false, searchData, "event_time", param.Page,
                param.Perpage, false, logs.AttackAlarmInfo.EsAliasIndex+"-"+param.Data.AppId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to search data from es", err)
        }</span>
        <span class="cov8" title="1">o.Serve(map[string]interface{}{
                "total":      total,
                "total_page": math.Ceil(float64(total) / float64(param.Perpage)),
                "page":       param.Page,
                "perpage":    param.Perpage,
                "data":       result,
        })</span>
}

// @router /aggr/vuln [post]
func (o *AttackAlarmController) AggregationVuln() <span class="cov8" title="1">{
        param, searchData := o.handleAttackSearchParam()
        total, result, err := logs.SearchLogs(param.Data.StartTime, param.Data.EndTime,
                true, searchData, "event_time", param.Page,
                param.Perpage, false, logs.AttackAlarmInfo.EsAliasIndex+"-"+param.Data.AppId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to search data from es", err)
        }</span>
        <span class="cov8" title="1">o.Serve(map[string]interface{}{
                "total":      total,
                "total_page": math.Ceil(float64(total) / float64(param.Perpage)),
                "page":       param.Page,
                "perpage":    param.Perpage,
                "data":       result,
        })</span>
}

func (o *AttackAlarmController) handleAttackSearchParam() (param *logs.SearchAttackParam,
        searchData map[string]interface{}) <span class="cov8" title="1">{
        param = &amp;logs.SearchAttackParam{}
        o.UnmarshalJson(&amp;param)
        if param.Data == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "search data can not be empty")
        }</span>
        <span class="cov8" title="1">if param.Data.AppId != "" </span><span class="cov8" title="1">{
                _, err := models.GetAppById(param.Data.AppId)
                if err != nil </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest, "cannot get the app: "+param.Data.AppId, err)
                }</span>
        } else<span class="cov8" title="1"> {
                param.Data.AppId = "*"
        }</span>
        <span class="cov8" title="1">if param.Data.StartTime &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time must be greater than 0")
        }</span>
        <span class="cov8" title="1">if param.Data.EndTime &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "end_time must be greater than 0")
        }</span>
        <span class="cov8" title="1">if param.Data.StartTime &gt; param.Data.EndTime </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time cannot be greater than end_time")
        }</span>
        <span class="cov8" title="1">o.ValidPage(param.Page, param.Perpage)
        content, err := json.Marshal(param.Data)
        if err != nil </span><span class="cov0" title="0">{
                o.ServeError(http.StatusBadRequest, "failed to encode search data", err)
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(content, &amp;searchData)
        if err != nil </span><span class="cov0" title="0">{
                o.ServeError(http.StatusBadRequest, "failed to decode search data", err)
        }</span>
        <span class="cov8" title="1">delete(searchData, "start_time")
        delete(searchData, "end_time")
        delete(searchData, "app_id")
        return</span>
}

func (o *AttackAlarmController) validFieldAggrParam(param *logs.AggrFieldParam) <span class="cov8" title="1">{
        if param.AppId != "" </span><span class="cov8" title="1">{
                _, err := models.GetAppById(param.AppId)
                if err != nil </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest, "cannot get the app: "+param.AppId, err)
                }</span>
        } else<span class="cov8" title="1"> {
                param.AppId = "*"
        }</span>
        <span class="cov8" title="1">if param.StartTime &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time must be greater than 0")
        }</span>
        <span class="cov8" title="1">if param.EndTime &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "end_time must be greater than 0")
        }</span>
        <span class="cov8" title="1">if param.StartTime &gt; param.EndTime </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time cannot be greater than end_time")
        }</span>
        <span class="cov8" title="1">duration := time.Duration(param.EndTime-param.StartTime) * time.Millisecond
        if duration &gt; 366*24*time.Hour </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "time duration can not be greater than 366 days")
        }</span>
        <span class="cov8" title="1">if param.Size &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "size must be greater than 0")
        }</span>
}
</pre>

      <pre
        class="file"
        id="file9"
        style="display: none"
      >//Copyright 2017-2018 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package fore_logs

import (
        "rasp-cloud/controllers"
        "encoding/json"
        "net/http"
        "rasp-cloud/models"
        "rasp-cloud/models/logs"
        "math"
)

type ErrorController struct {
        controllers.BaseController
}

// @router /search [post]
func (o *ErrorController) Search() <span class="cov8" title="1">{
        var param = &amp;logs.SearchErrorParam{}
        o.UnmarshalJson(&amp;param)
        if param.Data == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "search data can not be empty")
        }</span>
        <span class="cov8" title="1">if param.Data.AppId != "" </span><span class="cov8" title="1">{
                _, err := models.GetAppById(param.Data.AppId)
                if err != nil </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest, "cannot get the app: "+param.Data.AppId, err)
                }</span>
        } else<span class="cov8" title="1"> {
                param.Data.AppId = "*"
        }</span>
        <span class="cov8" title="1">o.ValidPage(param.Page, param.Perpage)
        if param.Data.StartTime &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time must be greater than 0")
        }</span>
        <span class="cov8" title="1">if param.Data.EndTime &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "end_time must be greater than 0")
        }</span>
        <span class="cov8" title="1">if param.Data.StartTime &gt; param.Data.EndTime </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time cannot be greater than end_time")
        }</span>
        <span class="cov8" title="1">content, err := json.Marshal(param.Data)
        if err != nil </span><span class="cov0" title="0">{
                o.ServeError(http.StatusBadRequest, "failed to encode search data", err)
        }</span>
        <span class="cov8" title="1">var searchData map[string]interface{}
        err = json.Unmarshal(content, &amp;searchData)
        if err != nil </span><span class="cov0" title="0">{
                o.ServeError(http.StatusBadRequest, "failed to decode search data", err)
        }</span>
        <span class="cov8" title="1">delete(searchData, "start_time")
        delete(searchData, "end_time")
        delete(searchData, "app_id")
        total, result, err := logs.SearchLogs(param.Data.StartTime, param.Data.EndTime, false, searchData, "event_time",
                param.Page, param.Perpage, false, logs.ErrorAlarmInfo.EsAliasIndex+"-"+param.Data.AppId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to search data from es", err)
        }</span>
        <span class="cov8" title="1">o.Serve(map[string]interface{}{
                "total":      total,
                "total_page": math.Ceil(float64(total) / float64(param.Perpage)),
                "page":       param.Page,
                "perpage":    param.Perpage,
                "data":       result,
        })</span>
}
</pre>

      <pre
        class="file"
        id="file10"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package fore_logs

import (
        "rasp-cloud/controllers"
        "rasp-cloud/models/logs"
        "encoding/json"
        "rasp-cloud/models"
        "net/http"
        "math"
)

// Operations about policy alarm message
type PolicyAlarmController struct {
        controllers.BaseController
}

// @router /search [post]
func (o *PolicyAlarmController) Search() <span class="cov8" title="1">{
        var param = &amp;logs.SearchPolicyParam{}
        o.UnmarshalJson(&amp;param)
        if param.Data == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "search data can not be empty")
        }</span>
        <span class="cov8" title="1">if param.Data.AppId != "" </span><span class="cov8" title="1">{
                _, err := models.GetAppById(param.Data.AppId)
                if err != nil </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest, "cannot get the app: "+param.Data.AppId, err)
                }</span>
        } else<span class="cov8" title="1"> {
                param.Data.AppId = "*"
        }</span>
        <span class="cov8" title="1">if param.Data.StartTime &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time must be greater than 0")
        }</span>
        <span class="cov8" title="1">if param.Data.EndTime &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "end_time must be greater than 0")
        }</span>
        <span class="cov8" title="1">if param.Data.StartTime &gt; param.Data.EndTime </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time cannot be greater than end_time")
        }</span>
        <span class="cov8" title="1">o.ValidPage(param.Page, param.Perpage)
        content, err := json.Marshal(param.Data)
        if err != nil </span><span class="cov0" title="0">{
                o.ServeError(http.StatusBadRequest, "failed to encode search data", err)
        }</span>
        <span class="cov8" title="1">var searchData map[string]interface{}
        err = json.Unmarshal(content, &amp;searchData)
        if err != nil </span><span class="cov0" title="0">{
                o.ServeError(http.StatusBadRequest, "failed to decode search data", err)
        }</span>
        <span class="cov8" title="1">delete(searchData, "start_time")
        delete(searchData, "end_time")
        delete(searchData, "app_id")
        total, result, err := logs.SearchLogs(param.Data.StartTime, param.Data.EndTime, false, searchData, "event_time",
                param.Page, param.Perpage, false, logs.PolicyAlarmInfo.EsAliasIndex+"-"+param.Data.AppId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to search data from es", err)
        }</span>
        <span class="cov8" title="1">o.Serve(map[string]interface{}{
                "total":      total,
                "total_page": math.Ceil(float64(total) / float64(param.Perpage)),
                "page":       param.Page,
                "perpage":    param.Perpage,
                "data":       result,
        })</span>
}
</pre>

      <pre
        class="file"
        id="file11"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package api

import (
        "math"
        "net/http"
        "rasp-cloud/controllers"
        "rasp-cloud/models"
)

type OperationController struct {
        controllers.BaseController
}

// @router /search [post]
func (o *OperationController) Search() <span class="cov8" title="1">{
        var param struct {
                Data      *models.Operation `json:"data"`
                StartTime int64             `json:"start_time"`
                EndTime   int64             `json:"end_time"`
                Page      int               `json:"page"`
                Perpage   int               `json:"perpage"`
        }
        o.UnmarshalJson(&amp;param)
        o.ValidPage(param.Page, param.Perpage)
        if param.Data == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "search data can not be empty")
        }</span>
        <span class="cov8" title="1">if param.StartTime &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time must be greater than 0")
        }</span>
        <span class="cov8" title="1">if param.EndTime &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "end_time must be greater than 0")
        }</span>
        <span class="cov8" title="1">if param.StartTime &gt; param.EndTime </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time cannot be greater than end_time")
        }</span>

        <span class="cov8" title="1">var result = make(map[string]interface{})
        total, operations, err := models.FindOperation(param.Data, param.StartTime, param.EndTime, param.Page, param.Perpage)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "Failed to get plugin list", err)
        }</span>
        <span class="cov8" title="1">result["total"] = total
        result["total_page"] = math.Ceil(float64(total) / float64(param.Perpage))
        result["page"] = param.Page
        result["perpage"] = param.Perpage
        result["data"] = operations
        o.Serve(result)</span>
}
</pre>

      <pre
        class="file"
        id="file12"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package api

import (
        "gopkg.in/mgo.v2"
        "gopkg.in/mgo.v2/bson"
        "io/ioutil"
        "net/http"
        "rasp-cloud/controllers"
        "rasp-cloud/models"
        "rasp-cloud/mongo"
)

// Operations about plugin
type PluginController struct {
        controllers.BaseController
}

// @router / [post]
func (o *PluginController) Upload() <span class="cov8" title="1">{
        appId := o.GetString("app_id")
        if appId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "app_id can not be empty")
        }</span>
        <span class="cov8" title="1">_, err := models.GetAppById(appId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get app", err)
        }</span>

        <span class="cov8" title="1">uploadFile, info, err := o.GetFile("plugin")
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "parse uploadFile error", err)
        }</span>
        <span class="cov8" title="1">if uploadFile == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "must have the plugin parameter")
        }</span>
        <span class="cov8" title="1">defer uploadFile.Close()

        if info.Size == 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the upload file cannot be empty")
        }</span>
        <span class="cov8" title="1">pluginContent, err := ioutil.ReadAll(uploadFile)
        if err != nil </span><span class="cov0" title="0">{
                o.ServeError(http.StatusBadRequest, "failed to read upload plugin", err)
        }</span>

        <span class="cov8" title="1">latestPlugin, err := models.AddPlugin(pluginContent, appId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to add plugin", err)
        }</span>
        <span class="cov8" title="1">models.AddOperation(appId, models.OperationTypeUploadPlugin, o.Ctx.Input.IP(),
                "New plugin uploaded: "+latestPlugin.Id)
        o.Serve(latestPlugin)</span>
}

// @router /get [post]
func (o *PluginController) Get() <span class="cov8" title="1">{
        var param map[string]string
        o.UnmarshalJson(&amp;param)
        pluginId := param["id"]
        if pluginId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "plugin_id cannot be empty")
        }</span>
        <span class="cov8" title="1">plugin, err := models.GetPluginById(pluginId, false)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get plugin", err)
        }</span>
        <span class="cov8" title="1">o.Serve(plugin)</span>
}

// @router /download [get]
func (o *PluginController) Download() <span class="cov8" title="1">{
        pluginId := o.GetString("id")
        plugin, err := models.GetPluginById(pluginId, true)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get plugin", err)
        }</span>
        <span class="cov8" title="1">o.Ctx.Output.Header("Content-Type", "text/plain")
        if plugin.Name == "" </span><span class="cov8" title="1">{
                plugin.Name = "plugin"
        }</span>
        <span class="cov8" title="1">o.Ctx.Output.Header("Content-Disposition", "attachment;filename="+plugin.Name+"-"+plugin.Version+".js")
        if len(plugin.OriginContent) != 0 </span><span class="cov8" title="1">{
                o.Ctx.Output.Body([]byte(plugin.OriginContent))
        }</span> else<span class="cov8" title="1"> {
                o.Ctx.Output.Body([]byte(plugin.Content))
        }</span>
}

// @router /algorithm/config [post]
func (o *PluginController) UpdateAppAlgorithmConfig() <span class="cov8" title="1">{
        var param struct {
                PluginId string                 `json:"id"`
                Config   map[string]interface{} `json:"config"`
        }
        o.UnmarshalJson(&amp;param)
        if param.PluginId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "plugin id can not be empty")
        }</span>
        <span class="cov8" title="1">if param.Config == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "config can not be empty")
        }</span>
        <span class="cov8" title="1">appId, err := models.UpdateAlgorithmConfig(param.PluginId, param.Config)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to update algorithm config", err)
        }</span>
        <span class="cov8" title="1">models.AddOperation(appId, models.OperationTypeUpdateAlgorithmConfig,
                o.Ctx.Input.IP(), "Algorithm config updated for plugin: "+param.PluginId)
        o.ServeWithEmptyData()</span>
}

// @router /algorithm/restore [post]
func (o *PluginController) RestoreAlgorithmConfig() <span class="cov8" title="1">{
        var param map[string]string
        o.UnmarshalJson(&amp;param)
        pluginId := param["id"]
        if pluginId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "plugin_id cannot be empty")
        }</span>
        <span class="cov8" title="1">appId, err := models.RestoreDefaultConfiguration(pluginId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to restore the default algorithm config", err)
        }</span>
        <span class="cov8" title="1">models.AddOperation(appId, models.OperationTypeRestorePlugin, o.Ctx.Input.IP(),
                "Restored algorithm config for plugin: "+pluginId)
        o.ServeWithEmptyData()</span>
}

// @router /delete [post]
func (o *PluginController) Delete() <span class="cov8" title="1">{
        var param map[string]string
        o.UnmarshalJson(&amp;param)
        pluginId := param["id"]
        if pluginId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "plugin_id cannot be empty")
        }</span>
        <span class="cov8" title="1">plugin, err := models.GetPluginById(pluginId, false)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "can not get the plugin", err)
        }</span>
        <span class="cov8" title="1">var app *models.App
        err = mongo.FindOne("app", bson.M{"selected_plugin_id": pluginId}, &amp;app)
        if err != nil &amp;&amp; err != mgo.ErrNotFound </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get app", err)
        }</span>
        <span class="cov8" title="1">if app != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "Unable to delete a plugin in use. Plugin is used by appid: "+app.Id)
        }</span>
        <span class="cov8" title="1">err = models.DeletePlugin(pluginId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to delete the plugin", err)
        }</span>
        <span class="cov8" title="1">models.AddOperation(plugin.AppId, models.OperationTypeDeletePlugin, o.Ctx.Input.IP(),
                "Deleted plugin: "+plugin.Id)
        o.ServeWithEmptyData()</span>
}
</pre>

      <pre
        class="file"
        id="file13"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package api

import (
        "math"
        "net/http"
        "rasp-cloud/controllers"
        "rasp-cloud/models"
        "github.com/astaxie/beego/validation"
)

type RaspController struct {
        controllers.BaseController
}

// @router /search [post]
func (o *RaspController) Search() <span class="cov8" title="1">{
        var param struct {
                Data    *models.Rasp `json:"data" `
                Page    int          `json:"page"`
                Perpage int          `json:"perpage"`
        }
        o.UnmarshalJson(&amp;param)
        if param.Data == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "search data can not be empty")
        }</span>
        <span class="cov8" title="1">o.ValidPage(param.Page, param.Perpage)
        total, rasps, err := models.FindRasp(param.Data, param.Page, param.Perpage)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get rasp", err)
        }</span>
        <span class="cov8" title="1">if rasps == nil </span><span class="cov8" title="1">{
                rasps = make([]*models.Rasp, 0)
        }</span>
        <span class="cov8" title="1">var result = make(map[string]interface{})
        result["total"] = total
        result["total_page"] = math.Ceil(float64(total) / float64(param.Perpage))
        result["page"] = param.Page
        result["perpage"] = param.Perpage
        result["data"] = rasps
        o.Serve(result)</span>
}

// @router /delete [post]
func (o *RaspController) Delete() <span class="cov8" title="1">{
        var rasp struct {
                Id          string `json:"id"`
                AppId       string `json:"app_id"`
                RegisterIp  string `json:"register_ip"`
                ExpiredTime int64  `json:"expire_time"`
        }
        o.UnmarshalJson(&amp;rasp)
        if rasp.AppId == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the app_id can not be empty")
        }</span>

        <span class="cov8" title="1">if rasp.Id != "" </span><span class="cov8" title="1">{
                err := models.RemoveRaspById(rasp.Id)
                if err != nil </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest, "failed to remove rasp by id", err)
                }</span>
                <span class="cov0" title="0">models.AddOperation(rasp.AppId, models.OperationTypeDeleteRasp, o.Ctx.Input.IP(),
                        "Deleted RASP agent by id: "+rasp.Id)
                o.Serve(map[string]interface{}{
                        "count": 1,
                })</span>
        } else<span class="cov8" title="1"> {
                selector := make(map[string]interface{})
                if rasp.ExpiredTime == 0 &amp;&amp; rasp.RegisterIp == "" </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest,
                                "expire_time and register ip can not be empty at the same time")
                }</span>
                <span class="cov8" title="1">if rasp.RegisterIp != "" </span><span class="cov8" title="1">{
                        selector["register_ip"] = rasp.RegisterIp
                        valid := validation.Validation{}
                        if result := valid.IP(rasp.RegisterIp, "IP"); !result.Ok </span><span class="cov8" title="1">{
                                o.ServeError(http.StatusBadRequest, "rasp register_ip format error"+result.Error.Message)
                        }</span>
                }
                <span class="cov8" title="1">if rasp.ExpiredTime != 0 </span><span class="cov8" title="1">{
                        selector["expire_time"] = rasp.ExpiredTime
                        if rasp.ExpiredTime &lt; 0 </span><span class="cov8" title="1">{
                                o.ServeError(http.StatusBadRequest, "expire_time must be greater than 0")
                        }</span>
                }
                <span class="cov8" title="1">removedCount, err := models.RemoveRaspBySelector(selector, rasp.AppId)
                if err != nil </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest, "failed to remove rasp by register ip", err)
                }</span>
                <span class="cov8" title="1">models.AddOperation(rasp.AppId, models.OperationTypeDeleteRasp, o.Ctx.Input.IP(),
                        "Deleted RASP agent by register ip: "+rasp.RegisterIp)
                o.Serve(map[string]interface{}{
                        "count": removedCount,
                })</span>
        }
}
</pre>

      <pre
        class="file"
        id="file14"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package api

import (
        "fmt"
        "net/http"
        "rasp-cloud/controllers"
        "rasp-cloud/models"
)

type ReportController struct {
        controllers.BaseController
}

var (
        intervals = [...]string{"hour", "day", "month"}
)

// @router /dashboard [post]
func (o *ReportController) Search() <span class="cov8" title="1">{
        var query map[string]interface{}
        o.UnmarshalJson(&amp;query)
        startTimeParam := query["start_time"]
        if startTimeParam == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time cannot be empty")
        }</span>
        <span class="cov8" title="1">startTime, ok := startTimeParam.(float64)
        if !ok </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time must be number")
        }</span>
        <span class="cov8" title="1">if startTime &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "start_time must be greater than 0")
        }</span>
        <span class="cov8" title="1">endTimeParam := query["end_time"]
        if endTimeParam == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "end_time cannot be empty")
        }</span>
        <span class="cov8" title="1">endTime, ok := endTimeParam.(float64)
        if !ok </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "end_time must be number")
        }</span>
        <span class="cov8" title="1">if endTime &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "end_time must be greater than 0")
        }</span>
        <span class="cov8" title="1">intervalParam := query["interval"]
        if intervalParam == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "interval cannot be empty")
        }</span>
        <span class="cov8" title="1">interval, ok := intervalParam.(string)
        if !ok </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "interval must be string")
        }</span>
        <span class="cov8" title="1">timeZoneParam := query["time_zone"]
        if timeZoneParam == nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "time_zone cannot be empty")
        }</span>
        <span class="cov8" title="1">timeZone, ok := timeZoneParam.(string)
        if !ok </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "time_zone must be string")
        }</span>
        <span class="cov8" title="1">isValidInterval := false
        for index := range intervals </span><span class="cov8" title="1">{
                if interval == intervals[index] </span><span class="cov8" title="1">{
                        isValidInterval = true
                }</span>
        }
        <span class="cov8" title="1">if !isValidInterval </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the interval must be in"+fmt.Sprintf("%v", intervals))
        }</span>
        <span class="cov8" title="1">appIdParam := query["app_id"]
        appId := "*"
        if appIdParam != nil </span><span class="cov8" title="1">{
                appId, ok = appIdParam.(string)
                if !ok </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest, "app_id must be string")
                }</span>
                <span class="cov8" title="1">_, err := models.GetAppById(appId)
                if err != nil </span><span class="cov8" title="1">{
                        o.ServeError(http.StatusBadRequest, "failed to get app", err)
                }</span>
        }
        <span class="cov8" title="1">err, result := models.GetHistoryRequestSum(int64(startTime), int64(endTime), interval, timeZone, appId)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get request sum form ES", err)
        }</span>
        <span class="cov8" title="1">o.Serve(result)</span>

}
</pre>

      <pre
        class="file"
        id="file15"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package api

import (
        "rasp-cloud/controllers"
        "rasp-cloud/models"
        "net/http"
        "gopkg.in/mgo.v2"
        "strings"
)

type ServerController struct {
        controllers.BaseController
}

// @router /url/get [post]
func (o *ServerController) GetUrl() <span class="cov8" title="1">{
        serverUrl, err := models.GetServerUrl()
        if err != nil </span><span class="cov8" title="1">{
                if mgo.ErrNotFound == err </span><span class="cov8" title="1">{
                        o.Serve(models.ServerUrl{AgentUrls: []string{}})
                        return
                }</span>
                <span class="cov8" title="1">o.ServeError(http.StatusBadRequest, "failed to get serverUrl", err)</span>
        }
        <span class="cov8" title="1">o.Serve(serverUrl)</span>
}

// @router /url [post]
func (o *ServerController) PutUrl() <span class="cov8" title="1">{
        var serverUrl = &amp;models.ServerUrl{}
        o.UnmarshalJson(&amp;serverUrl)

        if !validHttpUrl(serverUrl.PanelUrl) </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "Invalid panel url: "+serverUrl.PanelUrl)
        }</span>

        <span class="cov8" title="1">if len(serverUrl.PanelUrl) &gt; 512 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of panel url cannot be greater than 512")
        }</span>

        <span class="cov8" title="1">if len(serverUrl.AgentUrls) &gt; 1024 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the count of agent url cannot be greater than 1024")
        }</span>

        <span class="cov8" title="1">if serverUrl.AgentUrls != nil </span><span class="cov8" title="1">{
                for _, agentUrl := range serverUrl.AgentUrls </span><span class="cov8" title="1">{
                        if len(agentUrl) &gt; 512 </span><span class="cov8" title="1">{
                                o.ServeError(http.StatusBadRequest, "the length of agent url cannot be greater than 512")
                        }</span>
                        <span class="cov8" title="1">if !validHttpUrl(agentUrl) </span><span class="cov8" title="1">{
                                o.ServeError(http.StatusBadRequest, "Invalid agent url: "+agentUrl)
                        }</span>
                }
        }

        <span class="cov8" title="1">err := models.PutServerUrl(serverUrl)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to put server url", err)
        }</span>

        <span class="cov8" title="1">o.Serve(serverUrl)</span>
}

func validHttpUrl(url string) bool <span class="cov8" title="1">{
        return strings.HasPrefix(url, "http://") || strings.HasPrefix(url, "https://")
}</span>
</pre>

      <pre
        class="file"
        id="file16"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package api

import (
        "math"
        "net/http"
        "rasp-cloud/controllers"
        "rasp-cloud/models"
)

type TokenController struct {
        controllers.BaseController
}

// @router /get [post]
func (o *TokenController) Get() <span class="cov8" title="1">{
        var param map[string]int
        o.UnmarshalJson(&amp;param)
        page := param["page"]
        perpage := param["perpage"]
        o.ValidPage(page, perpage)

        total, tokens, err := models.GetAllToken(page, perpage)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to get tokens", err)
        }</span>
        <span class="cov8" title="1">if tokens == nil </span><span class="cov8" title="1">{
                tokens = make([]*models.Token, 0)
        }</span>
        <span class="cov8" title="1">var result = make(map[string]interface{})
        result["total"] = total
        result["total_page"] = math.Ceil(float64(total) / float64(perpage))
        result["page"] = page
        result["perpage"] = perpage
        result["data"] = tokens
        o.Serve(result)</span>
}

// @router / [post]
func (o *TokenController) Post() <span class="cov8" title="1">{
        var token *models.Token
        o.UnmarshalJson(&amp;token)
        if len(token.Description) &gt; 1024 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of the token description must be less than 1024")
        }</span>
        <span class="cov8" title="1">token, err := models.AddToken(token)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to create new token", err)
        }</span>
        <span class="cov8" title="1">o.Serve(token)</span>
}

// @router /delete [post]
func (o *TokenController) Delete() <span class="cov8" title="1">{
        var token *models.Token
        o.UnmarshalJson(&amp;token)
        if len(token.Token) == 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the token param cannot be empty")
        }</span>
        <span class="cov8" title="1">currentToken := o.Ctx.Input.Header(models.AuthTokenName)
        if currentToken == token.Token </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "can not delete the token currently in use")
        }</span>
        <span class="cov8" title="1">token, err := models.RemoveToken(token.Token)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "failed to remove token", err)
        }</span>
        <span class="cov8" title="1">o.Serve(token)</span>
}
</pre>

      <pre
        class="file"
        id="file17"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package api

import (
        "crypto/md5"
        "fmt"
        "math/rand"
        "net/http"
        "rasp-cloud/controllers"
        "rasp-cloud/models"
        "strconv"
        "time"
)

type UserController struct {
        controllers.BaseController
}

// @router /login [post]
func (o *UserController) Login() <span class="cov8" title="1">{
        var loginData map[string]string
        o.UnmarshalJson(&amp;loginData)
        logUser := loginData["username"]
        logPasswd := loginData["password"]
        if logUser == "" || logPasswd == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "username or password cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(logUser) &gt; 512 || len(logPasswd) &gt; 512 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "the length of username or password cannot be greater than 512")
        }</span>
        <span class="cov8" title="1">err := models.VerifyUser(logUser, logPasswd)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "username or password is incorrect", err)
        }</span>
        <span class="cov8" title="1">cookie := fmt.Sprintf("%x", md5.Sum([]byte(strconv.Itoa(rand.Intn(10000)) + logUser + "openrasp"+
                strconv.FormatInt(time.Now().UnixNano(), 10))))
        err = models.NewCookie(cookie)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusUnauthorized, "failed to create cookie", err)
        }</span>
        <span class="cov8" title="1">o.Ctx.SetCookie(models.AuthCookieName, cookie)
        o.ServeWithEmptyData()</span>
}

// @router /islogin [get,post]
func (o *UserController) IsLogin() <span class="cov8" title="1">{
        o.ServeWithEmptyData()
}</span>

// @router /update [post]
func (o *UserController) Update() <span class="cov8" title="1">{
        var param struct {
                OldPwd string `json:"old_password"`
                NewPwd string `json:"new_password"`
        }
        o.UnmarshalJson(&amp;param)
        if param.OldPwd == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "old_password can not be empty")
        }</span>
        <span class="cov8" title="1">if param.NewPwd == "" </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "new_password can not be empty")
        }</span>
        <span class="cov8" title="1">err := models.RemoveAllCookie()
        if err != nil </span><span class="cov0" title="0">{
                o.ServeError(http.StatusBadRequest, err.Error())
        }</span>
        <span class="cov8" title="1">err = models.UpdatePassword(param.OldPwd, param.NewPwd)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, err.Error())
        }</span>
        <span class="cov8" title="1">o.ServeWithEmptyData()</span>
}

// @router /logout [get,post]
func (o *UserController) Logout() <span class="cov8" title="1">{
        o.Ctx.SetCookie(models.AuthCookieName, "")
        cookie := o.Ctx.GetCookie(models.AuthCookieName)
        models.RemoveCookie(cookie)
        o.ServeWithEmptyData()
}</span>
</pre>

      <pre
        class="file"
        id="file18"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package controllers

import (
        "github.com/astaxie/beego"
        "net/http"
        "encoding/json"
)

// base controller
type BaseController struct {
        beego.Controller
}

func (o *BaseController) Serve(data interface{}) <span class="cov8" title="1">{
        o.Data["json"] = map[string]interface{}{"status": 0, "description": "ok", "data": data}
        o.ServeJSON()
}</span>

func (o *BaseController) ServeWithEmptyData() <span class="cov8" title="1">{
        o.Data["json"] = map[string]interface{}{"status": 0, "description": "ok", "data": make(map[string]interface{})}
        o.ServeJSON()
}</span>

func (o *BaseController) ServeError(code int, description string, err ...error) <span class="cov8" title="1">{
        if len(err) &gt; 0 &amp;&amp; err[0] != nil </span><span class="cov8" title="1">{
                description = description + ": " + err[0].Error()
        }</span>
        <span class="cov8" title="1">o.ServeStatusCode(code, description)
        panic(description)</span>
}

func (o *BaseController) ServeStatusCode(code int, description ...string) <span class="cov8" title="1">{
        var des string
        if len(description) == 0 </span><span class="cov8" title="1">{
                des = http.StatusText(code)
        }</span> else<span class="cov8" title="1"> {
                des = description[0]
        }</span>
        <span class="cov8" title="1">o.Data["json"] = map[string]interface{}{"status": code, "description": des}
        o.ServeJSON()</span>
}

func (o *BaseController) UnmarshalJson(v interface{}) <span class="cov8" title="1">{
        err := json.Unmarshal(o.Ctx.Input.RequestBody, v)
        if err != nil </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "Invalid JSON request", err)
        }</span>
}

func (o *BaseController) ValidPage(page int, perpage int) <span class="cov8" title="1">{
        if page &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "page must be greater than 0")
        }</span>
        <span class="cov8" title="1">if perpage &lt;= 0 </span><span class="cov8" title="1">{
                o.ServeError(http.StatusBadRequest, "perpage must be greater than 0")
        }</span>
        <span class="cov8" title="1">if perpage &gt; 100 </span><span class="cov0" title="0">{
                o.ServeError(http.StatusBadRequest, "perpage must be less than 100")
        }</span>
}
</pre>

      <pre
        class="file"
        id="file19"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package controllers

type ErrorController struct {
        BaseController
}

func (o *ErrorController) Error404() <span class="cov8" title="1">{
        o.ServeStatusCode(404)
}</span>

func (o *ErrorController) Error500() <span class="cov8" title="1">{
        o.ServeStatusCode(500)
}</span>

func (o *ErrorController) Error503() <span class="cov8" title="1">{
        o.ServeStatusCode(503)
}</span>

func (o *ErrorController) Error502() <span class="cov8" title="1">{
        o.ServeStatusCode(502)
}</span>
</pre>

      <pre class="file" id="file20" style="display: none">package controllers

type PingController struct {
        BaseController
}

// @router / [get,post]
func (o *PingController) Ping() <span class="cov8" title="1">{
        o.ServeWithEmptyData()
}</span>
</pre>

      <pre
        class="file"
        id="file21"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package environment

/*
const char* build_time(void)
{
static const char* psz_build_time = "["__DATE__ "  " __TIME__ "]";
return psz_build_time;
}
*/
import "C"

import (
        "flag"
        "github.com/astaxie/beego"
        "github.com/astaxie/beego/logs"
        "log"
        "os"
        "os/exec"
        "rasp-cloud/tools"
        "rasp-cloud/conf"
        "fmt"
        "golang.org/x/crypto/ssh/terminal"
        "syscall"
        "bytes"
)

var (
        Version   = "1.1"
        BuildTime = C.GoString(C.build_time())
)

func init() <span class="cov8" title="1">{
        StartFlag := &amp;conf.Flag{}
        StartFlag.StartType = flag.String("type", "", "use to provide different routers")
        StartFlag.Daemon = flag.Bool("d", false, "use to run as daemon process")
        StartFlag.Version = flag.Bool("version", false, "use to get version")
        flag.Parse()

        if *StartFlag.Version </span><span class="cov0" title="0">{
                fmt.Println(Version)
                fmt.Println("Build Time: " + BuildTime)
                os.Exit(0)
        }</span>
        <span class="cov8" title="1">if *StartFlag.StartType == conf.StartTypeReset </span><span class="cov0" title="0">{
                HandleReset(StartFlag)
        }</span>
        <span class="cov8" title="1">if *StartFlag.Daemon </span><span class="cov0" title="0">{
                HandleDaemon()
        }</span>
        <span class="cov8" title="1">initLogger()
        initEnvConf()
        if *StartFlag.StartType == "" </span><span class="cov8" title="1">{
                allType := conf.StartTypeDefault
                StartFlag.StartType = &amp;allType
        }</span>
        <span class="cov8" title="1">conf.InitConfig(StartFlag)
        beego.Info("===== start type: " + *StartFlag.StartType + " =====")</span>
}

func HandleReset(startFlag *conf.Flag) <span class="cov8" title="1">{
        fmt.Print("Enter new admin password: ")
        pwd1, err := terminal.ReadPassword(int(syscall.Stdin))
        fmt.Println()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("failed to read password from terminal: " + err.Error())
                os.Exit(tools.ErrCodeResetUserFailed)
        }</span>
        <span class="cov8" title="1">fmt.Print("Retype new admin password: ")
        pwd2, err := terminal.ReadPassword(int(syscall.Stdin))
        fmt.Println()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("failed to read password from terminal: " + err.Error())
                os.Exit(tools.ErrCodeResetUserFailed)
        }</span>
        <span class="cov8" title="1">if bytes.Compare(pwd1, pwd2) != 0 </span><span class="cov0" title="0">{
                fmt.Println("Sorry, passwords do not match")
                os.Exit(tools.ErrCodeResetUserFailed)
        }</span> else<span class="cov8" title="1"> {
                pwd := string(pwd1)
                startFlag.Password = &amp;pwd
        }</span>
}

func HandleDaemon() <span class="cov8" title="1">{
        err := fork()
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeInitChildProcessFailed, "failed to launch child process, error", err)
        }</span>
        <span class="cov8" title="1">log.Println("start successfully, for details please check the log in 'logs/api/agent-cloud.log'")
        os.Exit(0)</span>
}

func fork() (err error) <span class="cov8" title="1">{
        path := os.Args[0]
        var args []string
        if len(os.Args) &gt; 1 </span><span class="cov8" title="1">{
                for _, arg := range os.Args[1:] </span><span class="cov8" title="1">{
                        if arg == "-d" </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">args = append(args, arg)</span>
                }
        }
        <span class="cov8" title="1">log.Println("args:", args)
        cmd := exec.Command(path, args...)
        err = cmd.Start()
        return</span>
}

func initLogger() <span class="cov8" title="1">{
        logPath := tools.GetCurrentPathWithPanic() + "/logs/api"
        if isExists, _ := tools.PathExists(logPath); !isExists </span><span class="cov0" title="0">{
                err := os.MkdirAll(logPath, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        tools.Panic(tools.ErrCodeLogInitFailed, "failed to create logs/api dir", err)
                }</span>
        }
        <span class="cov8" title="1">logs.SetLogFuncCall(true)
        logs.SetLogger(logs.AdapterFile,
                `{"filename":"`+logPath+`/agent-cloud.log","daily":true,"maxdays":10,"perm":"0777"}`)</span>

}

func initEnvConf() <span class="cov8" title="1">{
        if beego.BConfig.RunMode == "dev" </span><span class="cov0" title="0">{
                logs.SetLevel(beego.LevelDebug)
        }</span> else<span class="cov8" title="1"> {
                logs.SetLevel(beego.LevelInformational)
                beego.BConfig.EnableErrorsShow = false
                beego.BConfig.EnableErrorsRender = false
        }</span>
}
</pre>

      <pre
        class="file"
        id="file22"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package es

import (
        "github.com/olivere/elastic"
        "time"
        "context"
        "github.com/astaxie/beego/logs"
        "strconv"
        "github.com/astaxie/beego"
        "rasp-cloud/tools"
        "fmt"
        "strings"
        "rasp-cloud/conf"
)

var (
        ElasticClient *elastic.Client
        Version       string
        ttlIndexes    = make(chan map[string]time.Duration, 1)
        minEsVersion  = "5.6.0"
)

func init() <span class="cov8" title="1">{
        ttlIndexes &lt;- make(map[string]time.Duration)
        if *conf.AppConfig.Flag.StartType != conf.StartTypeReset </span><span class="cov8" title="1">{
                esAddr := conf.AppConfig.EsAddr
                client, err := elastic.NewSimpleClient(elastic.SetURL(esAddr),
                        elastic.SetBasicAuth(conf.AppConfig.EsUser, conf.AppConfig.EsPwd),
                        elastic.SetSnifferTimeoutStartup(5*time.Second),
                        elastic.SetSnifferTimeout(5*time.Second),
                        elastic.SetSnifferInterval(30*time.Minute))
                if err != nil </span><span class="cov0" title="0">{
                        tools.Panic(tools.ErrCodeESInitFailed, "init ES failed", err)
                }</span>
                <span class="cov8" title="1">go startTTL(24 * time.Hour)

                Version, err = client.ElasticsearchVersion(esAddr)
                if err != nil </span><span class="cov0" title="0">{
                        tools.Panic(tools.ErrCodeESInitFailed, "failed to get es version", err)
                }</span>
                <span class="cov8" title="1">beego.Info("ES version: " + Version)
                if strings.Compare(Version, minEsVersion) &lt; 0 </span><span class="cov0" title="0">{
                        tools.Panic(tools.ErrCodeESInitFailed, "unable to support the ElasticSearch with a version lower than "+
                                minEsVersion+ ","+ " the current version is "+ Version, nil)
                }</span>
                <span class="cov8" title="1">ElasticClient = client</span>
        }
}

func startTTL(duration time.Duration) <span class="cov8" title="1">{
        ticker := time.NewTicker(duration)
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        DeleteExpiredData()</span>
                }
        }
}

func DeleteExpiredData() <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        beego.Error(r)
                }</span>
        }()
        <span class="cov8" title="1">ttls := &lt;-ttlIndexes
        defer func() </span><span class="cov8" title="1">{
                ttlIndexes &lt;- ttls
        }</span>()
        <span class="cov8" title="1">for index, duration := range ttls </span><span class="cov8" title="1">{
                expiredTime := strconv.FormatInt((time.Now().UnixNano()-int64(duration))/1000000, 10)
                ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
                r, err := ElasticClient.DeleteByQuery(index).QueryString("@timestamp:&lt;" + expiredTime).Do(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        if r != nil &amp;&amp; r.Failures != nil </span><span class="cov0" title="0">{
                                beego.Error(r.Failures)
                        }</span>
                        <span class="cov0" title="0">beego.Error("failed to delete expired data for index " + index + ": " + err.Error())</span>
                } else<span class="cov8" title="1"> {
                        var deleteNum int64
                        if r != nil </span><span class="cov8" title="1">{
                                deleteNum = r.Deleted
                        }</span>
                        <span class="cov8" title="1">beego.Info("delete expired data successfully for index " + index + ", total: " +
                                strconv.FormatInt(deleteNum, 10))</span>
                }
                <span class="cov8" title="1">cancel()</span>
        }
}

func RegisterTTL(duration time.Duration, index string) <span class="cov8" title="1">{
        ttls := &lt;-ttlIndexes
        defer func() </span><span class="cov8" title="1">{
                ttlIndexes &lt;- ttls
        }</span>()
        <span class="cov8" title="1">ttls[index] = duration</span>
}

func CreateTemplate(name string, body string) error <span class="cov8" title="1">{
        ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(15*time.Second))
        defer cancel()
        _, err := elastic.NewIndicesPutTemplateService(ElasticClient).Name(name).BodyString(body).Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">beego.Info("put es template: " + name)
        return nil</span>
}

func CreateEsIndex(index string) error <span class="cov8" title="1">{
        ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(15*time.Second))
        defer cancel()
        exists, err := ElasticClient.IndexExists(index).Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                createResult, err := ElasticClient.CreateIndex(index).Do(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">logs.Info("create es index: " + createResult.Index)
                if err != nil </span><span class="cov0" title="0">{
                        beego.Error("failed to create index with name " + index + ": " + err.Error())
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func Insert(index string, docType string, doc interface{}) (err error) <span class="cov8" title="1">{
        ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
        defer cancel()
        _, err = ElasticClient.Index().Index(index).Type(docType).BodyJson(doc).Do(ctx)
        return
}</span>

func BulkInsert(docType string, docs []map[string]interface{}) (err error) <span class="cov8" title="1">{
        bulkService := ElasticClient.Bulk()
        for _, doc := range docs </span><span class="cov8" title="1">{
                if doc["app_id"] == nil </span><span class="cov0" title="0">{
                        beego.Error("failed to get app_id param from alarm: " + fmt.Sprintf("%+v", doc))
                }</span>
                <span class="cov8" title="1">if appId, ok := doc["app_id"].(string); ok </span><span class="cov8" title="1">{
                        if docType == "policy-alarm" </span><span class="cov8" title="1">{

                                bulkService.Add(elastic.NewBulkUpdateRequest().
                                        Index("real-openrasp-" + docType + "-" + appId).
                                        Type(docType).
                                        Id(fmt.Sprint(doc["upsert_id"])).
                                        DocAsUpsert(true).
                                        Doc(doc))
                        }</span> else<span class="cov8" title="1"> {
                                if appId, ok := doc["app_id"].(string); ok </span><span class="cov8" title="1">{
                                        bulkService.Add(elastic.NewBulkIndexRequest().
                                                Index("real-openrasp-" + docType + "-" + appId).
                                                Type(docType).
                                                OpType("index").
                                                Doc(doc))
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        beego.Error("the type of alarm's app_id param is not string: " + fmt.Sprintf("%+v", doc))
                }</span>
        }
        <span class="cov8" title="1">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(15*time.Second))
        defer cancel()
        _, err = bulkService.Do(ctx)
        return err</span>
}
</pre>

      <pre
        class="file"
        id="file23"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package es

import (
        "rasp-cloud/conf"
        "rasp-cloud/tools"
)

var attackAlarmTemplate = `
                {
                        "template":"openrasp-attack-alarm-*",
                        "aliases" : {
                        "real-{index}" : {} 
                    },
                        "settings": {
                                "analysis": {
                                        "normalizer": {
                                                "lowercase_normalizer": {
                                                        "type": "custom",
                                                        "filter": ["lowercase"]
                                                }
                                        }     
                                }
                        },
                        "mappings": {
                                "attack-alarm": {
                                        "_all": {
                                                "enabled": false
                                        },
                                        "properties": {
                                                "@timestamp":{
                                                        "type":"date"
                                                },
                                                "request_method": {
                                                        "type": "keyword",
                                                        "ignore_above": 50
                                                },
                                                "target": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "server_ip": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "client_ip": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "referer": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "user_agent": {
                                                        "type": "keyword",
                                                        "ignore_above": 512
                                                },
                                                "attack_source": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "path": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "url": {
                                                        "type": "keyword",
                                                        "ignore_above": 256,
                                                        "normalizer": "lowercase_normalizer"
                                                },
                                                "event_type": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "server_hostname": {
                                                        "type": "keyword",
                                                        "ignore_above": 256,
                                                        "normalizer": "lowercase_normalizer"
                                                },
                                                "stack_md5": {
                                                        "type": "keyword",
                                                        "ignore_above": 64
                                                },
                                                "server_type": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "server_version": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "request_id": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "body": {
                                                        "type": "keyword"
                                                },
                                                "app_id": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "rasp_id": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "event_time": {
                                                        "type": "date"
                                                },
                                                "stack_trace": {
                                                        "type": "keyword"
                                                },
                                                "intercept_state": {
                                                        "type": "keyword",
                                                        "ignore_above": 64
                                                },
                                                "attack_type": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "attack_location": {
                                                        "type": "object",
                                                        "properties": {
                                                                "location_zh_cn":{
                                                                        "type": "keyword",
                                                                        "ignore_above": 256
                                                                },
                                                                "location_en":{
                                                                        "type": "keyword",
                                                                        "ignore_above": 256
                                                                },
                                                                "longitude":{
                                                                        "type": "double"
                                                                },
                                                                "latitude":{
                                                                        "type": "double"
                                                                }
                                                        }
                                                },
                                                "plugin_algorithm":{
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "plugin_name": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "plugin_confidence": {
                                                        "type": "short"
                                                },
                                                "attack_params": {
                                                        "type": "object",
                                                        "enabled":"false"
                                                },
                                                "plugin_message": {
                                                        "type": "keyword"
                                                },
                                                "server_nic": {
                                                        "type": "nested",
                                                        "properties": {
                                                                "name": {
                                                                        "type": "keyword",
                                                                        "ignore_above": 256
                                                                },
                                                                "ip": {
                                                                        "type": "keyword",
                                                                        "ignore_above": 256
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                }
        `
var policyAlarmTemplate = `
                {
                        "template":"openrasp-policy-alarm-*",
                        "aliases" : {
                        "real-{index}" : {} 
                    },
                        "settings": {
                                "analysis": {
                                        "normalizer": {
                                                "lowercase_normalizer": {
                                                        "type": "custom",
                                                        "filter": ["lowercase"]
                                                }
                                        }
                                }
                        },
                        "mappings": {
                                "policy-alarm": {
                                        "_all": {
                                                "enabled": false
                                        },
                                        "properties": {
                                                "@timestamp":{
                                                        "type":"date"
                                                },
                                                "event_type": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "server_hostname": {
                                                        "type": "keyword",
                                                        "ignore_above": 256,
                                                        "normalizer": "lowercase_normalizer"
                                                },
                                                "server_type": {
                                                        "type": "keyword",
                                                        "ignore_above": 64
                                                },
                                                "server_nic": {
                                                        "type": "nested",
                                                        "properties": {
                                                                "name": {
                                                                        "type": "keyword",
                                                                        "ignore_above": 256
                                                                },
                                                                "ip": {
                                                                        "type": "keyword",
                                                                        "ignore_above": 256
                                                                }
                                                        }
                                                },
                                                "app_id": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "rasp_id": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "event_time": {
                                                        "type": "date"
                                                },
                                                "stack_trace": {
                                                        "type": "keyword"
                                                },
                                                "policy_id": {
                                                        "type": "long"
                                                },
                                                "message": {
                                                        "type": "keyword"
                                                },
                                                "stack_md5": {
                                                        "type": "keyword",
                                                        "ignore_above": 64
                                                },
                                                "policy_params": {
                                                        "type": "object",
                                                        "enabled":"false"
                                                }
                                        }
                                }
                        }
                }
                `
var errorAlarmTemplate = `{
                        "template":"openrasp-error-alarm-*",
                        "aliases" : {
                        "real-{index}" : {} 
                    },
                        "settings": {
                                "analysis": {
                                        "normalizer": {
                                                "lowercase_normalizer": {
                                                        "type": "custom",
                                                        "filter": ["lowercase"]
                                                }
                                        }     
                                }
                        },
                        "mappings": {
                                "error-alarm": {
                                        "_all": {
                                                "enabled": false
                                        },
                                        "properties": {
                                                "@timestamp":{
                                                        "type":"date"
                                                },
                                                "app_id": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "rasp_id": {
                                                        "type": "keyword",
                                                        "ignore_above": 256
                                                },
                                                "message": {
                                                        "type": "keyword"
                                                },
                                                "level": {
                                                        "type": "keyword",
                                                        "ignore_above": 64
                                                },
                                                "err_code":{
                                                        "type": "long"
                                                },
                                                "stack_trace":{
                                                        "type": "keyword"
                                                },
                                                "pid":{
                                                        "type": "long"
                                                },
                                                "event_time": {
                                                        "type": "date"
                                                },
                                                "server_hostname": {
                                                        "type": "keyword",
                                                        "ignore_above": 256,
                                                        "normalizer": "lowercase_normalizer"
                                                },
                                                "server_nic": {
                                                        "type": "nested",
                                                        "properties": {
                                                                "name": {
                                                                        "type": "keyword",
                                                                        "ignore_above": 256
                                                                },
                                                                "ip": {
                                                                        "type": "keyword",
                                                                        "ignore_above": 256
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                }
        `
var reportDataTemplate = `
                {
                        "template":"openrasp-report-data-*",
                        "aliases" : {
                        "real-{index}" : {} 
                    },
                        "mappings": {
                                "report-data": {
                                        "_all": {
                                                "enabled": false
                                        },
                                        "properties": {
                                                "@timestamp":{
                                                        "type":"date"
                                         },
                                                "time": {
                                                        "type": "date"
                                                },
                                                "request_sum": {
                                                        "type": "long"
                                                },
                                                "rasp_id": {
                                                        "type": "keyword",
                                                        "ignore_above" : 256
                                                }
                                        }
                                }
                        }
                }
        `

func init() <span class="cov8" title="1">{
        if *conf.AppConfig.Flag.StartType != conf.StartTypeReset </span><span class="cov8" title="1">{
                templates := map[string]string{
                        "report-data-template":  reportDataTemplate,
                        "error-alarm-template":  errorAlarmTemplate,
                        "attack-alarm-template": attackAlarmTemplate,
                        "policy-alarm-template": policyAlarmTemplate,
                }

                for name, template := range templates </span><span class="cov8" title="1">{
                        err := CreateTemplate(name, template)
                        if err != nil </span><span class="cov0" title="0">{
                                tools.Panic(tools.ErrCodeESInitFailed, "failed to create es template: "+name, err)
                        }</span>
                }
        }
}
</pre>

      <pre
        class="file"
        id="file24"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package models

import (
        "rasp-cloud/mongo"
        "fmt"
        "strconv"
        "time"
        "math/rand"
        "rasp-cloud/tools"
        "gopkg.in/mgo.v2"
        "crypto/sha1"
        "gopkg.in/mgo.v2/bson"
        "rasp-cloud/models/logs"
        "github.com/astaxie/beego"
        "net/smtp"
        "os"
        "net/mail"
        "strings"
        "html/template"
        "bytes"
        "github.com/astaxie/beego/httplib"
        "errors"
        "crypto/sha256"
        "encoding/base64"
        "io/ioutil"
        "crypto/tls"
        "net"
        "rasp-cloud/conf"
        "net/url"
)

type App struct {
        Id               string                 `json:"id" bson:"_id"`
        Name             string                 `json:"name"  bson:"name"`
        Secret           string                 `json:"secret"  bson:"secret"`
        Language         string                 `json:"language"  bson:"language"`
        Description      string                 `json:"description"  bson:"description"`
        CreateTime       int64                  `json:"create_time"  bson:"create_time"`
        ConfigTime       int64                  `json:"config_time"  bson:"config_time"`
        GeneralConfig    map[string]interface{} `json:"general_config"  bson:"general_config"`
        WhitelistConfig  []WhitelistConfigItem  `json:"whitelist_config"  bson:"whitelist_config"`
        SelectedPluginId string                 `json:"selected_plugin_id" bson:"selected_plugin_id"`
        EmailAlarmConf   EmailAlarmConf         `json:"email_alarm_conf" bson:"email_alarm_conf"`
        DingAlarmConf    DingAlarmConf          `json:"ding_alarm_conf" bson:"ding_alarm_conf"`
        HttpAlarmConf    HttpAlarmConf          `json:"http_alarm_conf" bson:"http_alarm_conf"`
        AlgorithmConfig  map[string]interface{} `json:"algorithm_config"`
}

type WhitelistConfigItem struct {
        Url  string          `json:"url" bson:"url"`
        Hook map[string]bool `json:"hook" bson:"hook"`
}

type EmailAlarmConf struct {
        Enable     bool     `json:"enable" bson:"enable"`
        From       string   `json:"from" bson:"from"`
        ServerAddr string   `json:"server_addr" bson:"server_addr"`
        UserName   string   `json:"username" bson:"username"`
        Password   string   `json:"password" bson:"password"`
        Subject    string   `json:"subject" bson:"subject"`
        RecvAddr   []string `json:"recv_addr" bson:"recv_addr"`
        TlsEnable  bool     `json:"tls_enable" bson:"tls_enable"`
}

type DingAlarmConf struct {
        Enable     bool     `json:"enable" bson:"enable"`
        AgentId    string   `json:"agent_id" bson:"agent_id"`
        CorpId     string   `json:"corp_id" bson:"corp_id"`
        CorpSecret string   `json:"corp_secret" bson:"corp_secret"`
        RecvUser   []string `json:"recv_user" bson:"recv_user"`
        RecvParty  []string `json:"recv_party" bson:"recv_party"`
}

type HttpAlarmConf struct {
        Enable   bool     `json:"enable" bson:"enable"`
        RecvAddr []string `json:"recv_addr" bson:"recv_addr"`
}

type emailTemplateParam struct {
        Total        int64
        Alarms       []map[string]interface{}
        DetailedLink string
        AppName      string
        HttpPort     int
}

type dingResponse struct {
        ErrCode     int64  `json:"errcode"`
        ErrMsg      string `json:"errmsg"`
        AccessToken string `json:"access_token"`
}

const (
        appCollectionName = "app"
        defaultAppName    = "PHP 示例应用"
        SecreteMask       = "************"
)

var (
        lastAlarmTime        = time.Now().UnixNano() / 1000000
        DefaultGeneralConfig = map[string]interface{}{
                "clientip.header":    "ClientIP",
                "block.status_code":  302,
                "block.redirect_url": "https://rasp.baidu.com/blocked/?request_id=%request_id%",
                "block.content_xml": "&lt;?xml version=\"1.0\"?&gt;&lt;doc&gt;&lt;error&gt;true&lt;/error&gt;&lt;reason&gt;Request blocked by OpenRASP" +
                        "&lt;/reason&gt;&lt;request_id&gt;%request_id%&lt;/request_id&gt;&lt;/doc&gt;",
                "block.content_html": "&lt;/script&gt;&lt;script&gt;" +
                        "location.href=\"https://rasp.baidu.com/blocked2/?request_id=%request_id%\"&lt;/script&gt;",
                "block.content_json":        `{"error":true,"reason": "Request blocked by OpenRASP","request_id": "%request_id%"}`,
                "plugin.timeout.millis":     100,
                "body.maxbytes":             4096,
                "plugin.filter":             true,
                "plugin.maxstack":           100,
                "ognl.expression.minlength": 30,
                "log.maxstack":              50,
                "log.maxburst":              100,
                "log.maxbackup":             30,
                "syslog.tag":                "OpenRASP",
                "syslog.url":                "",
                "syslog.facility":           1,
                "syslog.enable":             false,
                "decompile.enable":          false,
        }
)

func init() <span class="cov8" title="1">{
        count, err := mongo.Count(appCollectionName)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeMongoInitFailed, "failed to get app collection count", err)
        }</span>

        <span class="cov8" title="1">index := &amp;mgo.Index{
                Key:        []string{"name"},
                Unique:     true,
                Background: true,
                Name:       "app_name",
        }
        err = mongo.CreateIndex(appCollectionName, index)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeMongoInitFailed, "failed to create index for app collection", err)
        }</span>

        <span class="cov8" title="1">if *conf.AppConfig.Flag.StartType == conf.StartTypeDefault ||
                *conf.AppConfig.Flag.StartType == conf.StartTypeForeground </span><span class="cov8" title="1">{
                if count &lt;= 0 </span><span class="cov0" title="0">{
                        createDefaultApp()
                }</span>
                <span class="cov8" title="1">go startAlarmTicker(time.Second * time.Duration(conf.AppConfig.AlarmCheckInterval))</span>
        }
        <span class="cov8" title="1">if *conf.AppConfig.Flag.StartType != conf.StartTypeReset </span><span class="cov8" title="1">{
                initApp()
        }</span>
}

func initApp() error <span class="cov8" title="1">{
        var apps []*App
        _, err := mongo.FindAllWithoutLimit(appCollectionName, nil, &amp;apps)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeMongoInitFailed, "failed to get all app", err)
        }</span>
        <span class="cov8" title="1">for _, app := range apps </span><span class="cov8" title="1">{
                err := createEsIndexWithAppId(app.Id)
                if err != nil </span><span class="cov0" title="0">{
                        tools.Panic(tools.ErrCodeESInitFailed, "failed to init es index for app "+app.Name, err)
                }</span>
                <span class="cov8" title="1">if *conf.AppConfig.Flag.StartType != conf.StartTypeAgent </span><span class="cov8" title="1">{
                        err := initPlugin(app)
                        if err != nil </span><span class="cov0" title="0">{
                                beego.Warn(tools.ErrCodeInitDefaultAppFailed, "failed to init plugin for app ["+app.Name+"]", err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func initPlugin(app *App) error <span class="cov8" title="1">{
        content, err := getDefaultPluginContent()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">plugin, err := generatePlugin(content, app.Id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = mongo.FindOne(pluginCollectionName, bson.M{
                "name":    plugin.Name,
                "version": plugin.Version,
                "app_id":  plugin.AppId}, plugin)
        if err != nil </span><span class="cov8" title="1">{
                if err == mgo.ErrNotFound </span><span class="cov8" title="1">{
                        err = addPluginToDb(plugin)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func createEsIndexWithAppId(appId string) error <span class="cov8" title="1">{
        err := logs.CreateAlarmEsIndex(appId)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("failed to create alarm es index, " + err.Error())
        }</span>
        <span class="cov8" title="1">err = CreateReportDataEsIndex(appId)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to create report data es index, " + err.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func createDefaultApp() <span class="cov0" title="0">{
        _, err := AddApp(&amp;App{
                Name:        defaultAppName,
                Description: "default app",
                Language:    "php",
        })
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeInitDefaultAppFailed, "failed to create default app", err)
        }</span>
}

func startAlarmTicker(interval time.Duration) <span class="cov8" title="1">{
        ticker := time.NewTicker(interval)
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        HandleAttackAlarm()</span>
                }
        }
}

func HandleAttackAlarm() <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        beego.Error("failed to handle alarm: ", r)
                }</span>
        }()
        <span class="cov8" title="1">var apps []App
        _, err := mongo.FindAllWithSelect(appCollectionName, nil, &amp;apps, bson.M{"plugin": 0}, 0, 0)
        if err != nil </span><span class="cov8" title="1">{
                beego.Error("failed to get apps for the alarm: " + err.Error())
                return
        }</span>
        <span class="cov8" title="1">now := time.Now().UnixNano() / 1000000
        for _, app := range apps </span><span class="cov8" title="1">{
                total, result, err := logs.SearchLogs(lastAlarmTime, now, false, nil, "event_time",
                        1, 10, false, logs.AttackAlarmInfo.EsAliasIndex+"-"+app.Id)
                if err != nil </span><span class="cov8" title="1">{
                        beego.Error("failed to get alarm from es: " + err.Error())
                        continue</span>
                }
                <span class="cov8" title="1">if total &gt; 0 </span><span class="cov8" title="1">{
                        PushAttackAlarm(&amp;app, total, result, false)
                }</span>
        }
        <span class="cov8" title="1">lastAlarmTime = now + 1</span>
}

func AddApp(app *App) (result *App, err error) <span class="cov8" title="1">{
        app.Id = generateAppId(app)
        app.Secret = generateSecret(app)
        app.CreateTime = time.Now().Unix()
        if err := mongo.FindOne(appCollectionName, bson.M{"name": app.Name}, &amp;App{}); err != mgo.ErrNotFound </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, errors.New("duplicate app name")</span>
        }
        <span class="cov8" title="1">HandleApp(app, true)
        err = createEsIndexWithAppId(app.Id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("failed to create es index for app " + app.Name + ", " + err.Error())
        }</span>
        // ES must be created before mongo
        <span class="cov8" title="1">err = mongo.Insert(appCollectionName, app)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("failed to insert app to db: " + err.Error())
        }</span>
        <span class="cov8" title="1">result = app
        beego.Info("Succeed to create app, name: " + app.Name)
        selectDefaultPlugin(app)
        return</span>
}

func getDefaultPluginContent() ([]byte, error) <span class="cov8" title="1">{
        // if setting default plugin fails, continue to initialize
        currentPath, err := tools.GetCurrentPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to get get default plugin directory: " + err.Error())
        }</span>
        <span class="cov8" title="1">content, err := ioutil.ReadFile(currentPath + "/resources/plugin.js")
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to read default plugin content: " + err.Error())
        }</span>
        <span class="cov8" title="1">return content, err</span>
}

func selectDefaultPlugin(app *App) <span class="cov8" title="1">{
        // if setting default plugin fails, continue to initialize
        content, err := getDefaultPluginContent()
        if err != nil </span><span class="cov0" title="0">{
                beego.Warn(tools.ErrCodeInitDefaultAppFailed, "failed to get default plugin: "+err.Error())
                return
        }</span>
        <span class="cov8" title="1">plugin, err := AddPlugin(content, app.Id)
        if err != nil </span><span class="cov0" title="0">{
                beego.Warn(tools.ErrCodeInitDefaultAppFailed, "failed to insert default plugin: "+err.Error())
                return
        }</span>
        <span class="cov8" title="1">_, err = SetSelectedPlugin(app.Id, plugin.Id)
        if err != nil </span><span class="cov0" title="0">{
                beego.Warn(tools.ErrCodeInitDefaultAppFailed, "failed to select default plugin for app: " + err.Error()+
                        ", app_id: "+ app.Id+ ", plugin_id: "+ plugin.Id)
                return
        }</span>
        <span class="cov8" title="1">beego.Info("Succeed to set up default plugin for app, version: " + plugin.Version)</span>
}

func generateAppId(app *App) string <span class="cov8" title="1">{
        random := "openrasp_app" + app.Name + strconv.FormatInt(time.Now().UnixNano(), 10) + strconv.Itoa(rand.Intn(10000))
        return fmt.Sprintf("%x", sha1.Sum([]byte(random)))
}</span>

func generateSecret(app *App) string <span class="cov8" title="1">{
        random := "openrasp_app" + app.Name + app.Id +
                strconv.FormatInt(time.Now().UnixNano(), 10) + strconv.Itoa(rand.Intn(10000))
        sha256Data := sha256.Sum256([]byte(random))
        base64Data := base64.StdEncoding.EncodeToString(sha256Data[0:])
        return base64Data[0 : len(base64Data)-1]
}</span>

func GetAllApp(page int, perpage int, mask bool) (count int, result []*App, err error) <span class="cov8" title="1">{
        count, err = mongo.FindAll(appCollectionName, nil, &amp;result, perpage*(page-1), perpage, "name")
        if err == nil &amp;&amp; result != nil </span><span class="cov8" title="1">{
                for _, app := range result </span><span class="cov8" title="1">{
                        if mask </span><span class="cov8" title="1">{
                                HandleApp(app, false)
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func GetAppByIdWithoutMask(id string) (app *App, err error) <span class="cov8" title="1">{
        err = mongo.FindId(appCollectionName, id, &amp;app)
        return
}</span>

func GetAppById(id string) (app *App, err error) <span class="cov8" title="1">{
        err = mongo.FindId(appCollectionName, id, &amp;app)
        if err == nil &amp;&amp; app != nil </span><span class="cov8" title="1">{
                HandleApp(app, false)
        }</span>
        <span class="cov8" title="1">return</span>
}

func GetSecretByAppId(appId string) (secret string, err error) <span class="cov8" title="1">{
        newSession := mongo.NewSession()
        defer newSession.Close()
        var result *App
        err = newSession.DB(mongo.DbName).C(appCollectionName).FindId(appId).Select(bson.M{"secret": 1}).One(&amp;result)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if result != nil </span><span class="cov8" title="1">{
                secret = result.Secret
        }</span>
        <span class="cov8" title="1">return</span>
}

func RegenerateSecret(appId string) (secret string, err error) <span class="cov8" title="1">{
        var app *App
        err = mongo.FindId(appCollectionName, appId, &amp;app)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">newSecret := generateSecret(app)
        err = mongo.UpdateId(appCollectionName, appId, bson.M{"secret": newSecret})
        return</span>
}

func HandleApp(app *App, isCreate bool) error <span class="cov8" title="1">{
        if app.EmailAlarmConf.RecvAddr == nil </span><span class="cov8" title="1">{
                app.EmailAlarmConf.RecvAddr = make([]string, 0)
        }</span>
        <span class="cov8" title="1">if app.DingAlarmConf.RecvParty == nil </span><span class="cov8" title="1">{
                app.DingAlarmConf.RecvParty = make([]string, 0)
        }</span>
        <span class="cov8" title="1">if app.DingAlarmConf.RecvUser == nil </span><span class="cov8" title="1">{
                app.DingAlarmConf.RecvUser = make([]string, 0)
        }</span>
        <span class="cov8" title="1">if app.HttpAlarmConf.RecvAddr == nil </span><span class="cov8" title="1">{
                app.HttpAlarmConf.RecvAddr = make([]string, 0)
        }</span>
        <span class="cov8" title="1">if !isCreate </span><span class="cov8" title="1">{
                if app.EmailAlarmConf.Password != "" </span><span class="cov8" title="1">{
                        app.EmailAlarmConf.Password = SecreteMask
                }</span>
                <span class="cov8" title="1">if app.DingAlarmConf.CorpSecret != "" </span><span class="cov8" title="1">{
                        app.DingAlarmConf.CorpSecret = SecreteMask
                }</span>
        } else<span class="cov8" title="1"> {
                if app.GeneralConfig == nil </span><span class="cov0" title="0">{
                        app.GeneralConfig = DefaultGeneralConfig
                }</span>
        }
        <span class="cov8" title="1">if app.WhitelistConfig == nil </span><span class="cov8" title="1">{
                app.WhitelistConfig = make([]WhitelistConfigItem, 0)
        }</span>
        <span class="cov8" title="1">if app.GeneralConfig == nil </span><span class="cov8" title="1">{
                app.GeneralConfig = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">app.AlgorithmConfig = make(map[string]interface{})
        plugin, err := GetSelectedPlugin(app.Id, false)
        if err != nil </span><span class="cov8" title="1">{
                if err != mgo.ErrNotFound </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">if plugin != nil &amp;&amp; plugin.AlgorithmConfig != nil </span><span class="cov8" title="1">{
                app.AlgorithmConfig = plugin.AlgorithmConfig
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func UpdateAppById(id string, doc interface{}) (app *App, err error) <span class="cov8" title="1">{
        err = mongo.UpdateId(appCollectionName, id, doc)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return GetAppById(id)</span>
}

func UpdateGeneralConfig(appId string, config map[string]interface{}) (*App, error) <span class="cov8" title="1">{
        return UpdateAppById(appId, bson.M{"general_config": config, "config_time": time.Now().UnixNano()})
}</span>

func UpdateWhiteListConfig(appId string, config []WhitelistConfigItem) (app *App, err error) <span class="cov8" title="1">{
        return UpdateAppById(appId, bson.M{"whitelist_config": config, "config_time": time.Now().UnixNano()})
}</span>

func RemoveAppById(id string) (app *App, err error) <span class="cov8" title="1">{
        err = mongo.FindId(appCollectionName, id, &amp;app)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return app, mongo.RemoveId(appCollectionName, id)</span>
}

func GetAppCount() (count int, err error) <span class="cov8" title="1">{
        return mongo.Count(appCollectionName)
}</span>

func PushAttackAlarm(app *App, total int64, alarms []map[string]interface{}, isTest bool) <span class="cov8" title="1">{
        if app != nil </span><span class="cov8" title="1">{
                if app.DingAlarmConf.Enable </span><span class="cov8" title="1">{
                        PushDingAttackAlarm(app, total, alarms, isTest)
                }</span>
                <span class="cov8" title="1">if app.EmailAlarmConf.Enable </span><span class="cov8" title="1">{
                        PushEmailAttackAlarm(app, total, alarms, isTest)
                }</span>
                <span class="cov8" title="1">if app.HttpAlarmConf.Enable </span><span class="cov8" title="1">{
                        PushHttpAttackAlarm(app, total, alarms, isTest)
                }</span>
        }
}

func getTestAlarmData() []map[string]interface{} <span class="cov8" title="1">{
        return []map[string]interface{}{
                {
                        "event_time":      time.Now().Format("2006-01-01 15:06:05"),
                        "attack_source":   "220.181.57.191",
                        "attack_type":     "sql",
                        "intercept_state": "block",
                        "url":             "http://www.example.com/article.php?id=1",
                },
                {
                        "event_time":      time.Now().Format("2006-01-01 15:03:01"),
                        "attack_source":   "220.23.38.115",
                        "attack_type":     "command",
                        "intercept_state": "log",
                        "url":             "http://www.example.com/login.php?id=2",
                        "client_ip":       "220.22.13.3",
                },
        }
}</span>

func PushEmailAttackAlarm(app *App, total int64, alarms []map[string]interface{}, isTest bool) error <span class="cov8" title="1">{
        var emailConf = app.EmailAlarmConf
        if len(emailConf.RecvAddr) &gt; 0 &amp;&amp; emailConf.ServerAddr != "" </span><span class="cov8" title="1">{
                var (
                        subject   string
                        msg       string
                        emailAddr = &amp;mail.Address{Address: emailConf.UserName}
                )
                if emailConf.From != "" </span><span class="cov8" title="1">{
                        emailAddr.Name = emailConf.From
                }</span> else<span class="cov8" title="1"> {
                        hostName, err := os.Hostname()
                        if err == nil </span><span class="cov8" title="1">{
                                emailAddr.Name = hostName
                        }</span> else<span class="cov8" title="1"> {
                                emailAddr.Name = "OpenRASP"
                        }</span>
                }
                <span class="cov8" title="1">if emailConf.Subject == "" </span><span class="cov8" title="1">{
                        subject = "OpenRASP alarm"
                }</span> else<span class="cov8" title="1"> {
                        subject = emailConf.Subject
                }</span>
                <span class="cov8" title="1">if isTest </span><span class="cov8" title="1">{
                        subject = "【测试邮件】" + subject
                        alarms = getTestAlarmData()
                        total = int64(len(alarms))
                }</span>
                <span class="cov8" title="1">head := map[string]string{
                        "From":              emailAddr.String(),
                        "To":                strings.Join(emailConf.RecvAddr, ","),
                        "Subject":           subject,
                        "Content-Type":      "text/html; charset=UTF-8",
                        "X-Priority":        "3",
                        "X-MSMail-Priority": "Normal",
                        "X-Mailer":          "Microsoft Outlook Express 6.00.2900.2869",
                        "X-MimeOLE":         "Produced By Microsoft MimeOLE V6.00.2900.2869",
                        "ReturnReceipt":     "1",
                }
                t, err := template.ParseFiles("views/email.tpl")
                if err != nil </span><span class="cov8" title="1">{
                        beego.Error("failed to render email template: " + err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">alarmData := new(bytes.Buffer)
                panelUrl, port := getPanelServerUrl()
                handleAlarms(alarms)
                err = t.Execute(alarmData, &amp;emailTemplateParam{
                        Total:        total - int64(len(alarms)),
                        Alarms:       alarms,
                        AppName:      app.Name,
                        DetailedLink: panelUrl + "/#/events/" + app.Id,
                        HttpPort:     port,
                })
                if err != nil </span><span class="cov8" title="1">{
                        beego.Error("failed to execute email template: " + err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">for k, v := range head </span><span class="cov8" title="1">{
                        msg += fmt.Sprintf("%s: %s\r\n", k, v)
                }</span>
                <span class="cov8" title="1">msg += "\r\n" + alarmData.String()
                if !strings.Contains(emailConf.ServerAddr, ":") </span><span class="cov8" title="1">{
                        if emailConf.TlsEnable </span><span class="cov8" title="1">{
                                emailConf.ServerAddr += ":465"
                        }</span> else<span class="cov8" title="1"> {
                                emailConf.ServerAddr += ":25"
                        }</span>
                }
                //host, _, err := net.SplitHostPort(emailConf.ServerAddr)
                //if err != nil {
                //        return handleError("failed to get email serve host: " + err.Error())
                //}
                <span class="cov8" title="1">auth := tools.LoginAuth(emailConf.UserName, emailConf.Password)
                //auth := smtp.PlainAuth("", emailConf.UserName, emailConf.Password, host)
                //auth := smtp.CRAMMD5Auth(emailConf.UserName, emailConf.Password)
                if emailConf.Password == "" </span><span class="cov8" title="1">{
                        auth = nil
                }</span>
                <span class="cov8" title="1">if emailConf.TlsEnable </span><span class="cov8" title="1">{
                        return sendEmailWithTls(emailConf, auth, msg)
                }</span>
                <span class="cov8" title="1">return sendNormalEmail(emailConf, auth, msg)</span>
        } else<span class="cov8" title="1"> {
                beego.Error(
                        "failed to send email alarm: the email receiving address and email server address can not be empty", emailConf)
                return errors.New("the email receiving address and email server address can not be empty")
        }</span>
}

func handleAlarms(alarms []map[string]interface{}) <span class="cov8" title="1">{
        for index, alarm := range alarms </span><span class="cov8" title="1">{
                alarm["index"] = index + 1
                if intercept, ok := logs.AttackInterceptMap[alarm["intercept_state"]]; ok </span><span class="cov8" title="1">{
                        alarm["intercept_state"] = intercept
                }</span>

                <span class="cov8" title="1">if attackType, ok := logs.AttackTypeMap[alarm["attack_type"]]; ok </span><span class="cov8" title="1">{
                        alarm["attack_type"] = attackType
                }</span> else<span class="cov0" title="0"> {
                        alarm["attack_type"] = "其他类型"
                }</span>

                <span class="cov8" title="1">if alarm["url"] != nil </span><span class="cov8" title="1">{
                        if attackUrl, ok := alarm["url"].(string); ok &amp;&amp; attackUrl != "" </span><span class="cov8" title="1">{
                                attackUrl, err := url.Parse(attackUrl)
                                if err == nil </span><span class="cov8" title="1">{
                                        alarm["domain"] = attackUrl.Host
                                }</span>
                        }
                }

                <span class="cov8" title="1">if alarm["client_ip"] != nil </span><span class="cov8" title="1">{
                        if clientIp, ok := alarm["client_ip"].(string); ok &amp;&amp; clientIp != "" </span><span class="cov8" title="1">{
                                alarm["attack_source"] = clientIp
                        }</span>
                }
        }
}

func getPanelServerUrl() (string, int) <span class="cov8" title="1">{
        serverUrl, err := GetServerUrl()

        if err != nil &amp;&amp; err != mgo.ErrNotFound </span><span class="cov0" title="0">{
                beego.Error("failed to get panel url for alarm: " + err.Error())
        }</span>

        <span class="cov8" title="1">port := beego.AppConfig.DefaultInt("httpport", 8080)
        if serverUrl == nil || len(serverUrl.PanelUrl) == 0 </span><span class="cov0" title="0">{
                return "", port
        }</span>

        <span class="cov8" title="1">return serverUrl.PanelUrl, port</span>
}

func sendNormalEmail(emailConf EmailAlarmConf, auth smtp.Auth, msg string) (err error) <span class="cov8" title="1">{
        err = smtp.SendMail(emailConf.ServerAddr, auth, emailConf.UserName, emailConf.RecvAddr, []byte(msg))
        if err != nil </span><span class="cov8" title="1">{
                beego.Error("failed to push email alarms: " + err.Error())
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func sendEmailWithTls(emailConf EmailAlarmConf, auth smtp.Auth, msg string) error <span class="cov8" title="1">{
        client, err := smtpTlsDial(emailConf.ServerAddr)
        if err != nil </span><span class="cov8" title="1">{
                return handleError("failed to start tls: " + err.Error())
        }</span>
        <span class="cov8" title="1">if client.Text != nil </span><span class="cov0" title="0">{
                defer client.Close()
        }</span>
        <span class="cov8" title="1">if auth != nil </span><span class="cov8" title="1">{
                if ok, _ := client.Extension("AUTH"); ok </span><span class="cov8" title="1">{
                        if err = client.Auth(auth); err != nil </span><span class="cov8" title="1">{
                                return handleError("failed to auth with tls: " + err.Error())
                        }</span>
                }
        }
        <span class="cov8" title="1">if err = client.Mail(emailConf.UserName); err != nil </span><span class="cov8" title="1">{
                return handleError("failed to mail from 'emailConf.UserName': " + err.Error())
        }</span>

        <span class="cov8" title="1">for _, addr := range emailConf.RecvAddr </span><span class="cov8" title="1">{
                if err = client.Rcpt(addr); err != nil </span><span class="cov8" title="1">{
                        return handleError("failed to push email to " + addr + " with tls: " + err.Error())
                }</span>
        }

        <span class="cov8" title="1">writer, err := client.Data()
        if err != nil </span><span class="cov8" title="1">{
                return handleError("failed to get writer for email with tls: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer writer.Close()

        _, err = writer.Write([]byte(msg))
        if err != nil </span><span class="cov0" title="0">{
                return handleError("failed to write msg with tls: " + err.Error())
        }</span>

        <span class="cov8" title="1">if client.Text != nil </span><span class="cov0" title="0">{
                client.Quit()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func handleError(msg string) error <span class="cov8" title="1">{
        beego.Error(msg)
        return errors.New(msg)
}</span>

func smtpTlsDial(addr string) (*smtp.Client, error) <span class="cov8" title="1">{
        host, _, err := net.SplitHostPort(addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, handleError("failed to get email serve host: " + err.Error())
        }</span>
        <span class="cov8" title="1">conn, err := tls.DialWithDialer(&amp;net.Dialer{Timeout: time.Second * 5}, "tcp",
                addr, &amp;tls.Config{InsecureSkipVerify: true})
        if err != nil </span><span class="cov8" title="1">{
                return nil, handleError("smtp dialing error: " + err.Error())
        }</span>
        <span class="cov8" title="1">return smtp.NewClient(conn, host)</span>
}

func PushHttpAttackAlarm(app *App, total int64, alarms []map[string]interface{}, isTest bool) error <span class="cov8" title="1">{
        var httpConf = app.HttpAlarmConf
        if len(httpConf.RecvAddr) != 0 </span><span class="cov8" title="1">{
                body := make(map[string]interface{})
                body["app_id"] = app.Id
                if isTest </span><span class="cov8" title="1">{
                        body["data"] = getTestAlarmData()
                }</span> else<span class="cov8" title="1"> {
                        body["data"] = alarms
                }</span>
                <span class="cov8" title="1">for _, addr := range httpConf.RecvAddr </span><span class="cov8" title="1">{
                        request := httplib.Post(addr)
                        request.JSONBody(body)
                        request.SetTimeout(10*time.Second, 10*time.Second)
                        response, err := request.Response()
                        if err != nil </span><span class="cov0" title="0">{
                                return handleError("failed to push http alarms to: " + addr + ", with error: " + err.Error())
                        }</span>
                        <span class="cov8" title="1">if response.StatusCode &gt; 299 || response.StatusCode &lt; 200 </span><span class="cov0" title="0">{
                                return handleError("failed to push http alarms to: " + addr + ", with status code: " +
                                        strconv.Itoa(response.StatusCode))
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                return handleError("failed to send http alarm: the http receiving address can not be empty")
        }</span>
        <span class="cov8" title="1">beego.Debug("succeed in pushing http alarm for app: " + app.Name + " ,with urls: " +
                fmt.Sprintf("%v", httpConf.RecvAddr))
        return nil</span>
}

func PushDingAttackAlarm(app *App, total int64, alarms []map[string]interface{}, isTest bool) error <span class="cov8" title="1">{
        var dingCong = app.DingAlarmConf
        if dingCong.CorpId != "" &amp;&amp; dingCong.CorpSecret != "" &amp;&amp; dingCong.AgentId != "" &amp;&amp;
                !(len(dingCong.RecvParty) == 0 &amp;&amp; len(dingCong.RecvUser) == 0) </span><span class="cov8" title="1">{

                request := httplib.Get("https://oapi.dingtalk.com/gettoken")
                request.SetTimeout(10*time.Second, 10*time.Second)
                request.Param("corpid", dingCong.CorpId)
                request.Param("corpsecret", dingCong.CorpSecret)
                response, err := request.Response()
                errMsg := "failed to get ding ding token with corp id: " + dingCong.CorpId
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(errMsg + ", with error: " + err.Error())
                }</span>
                <span class="cov8" title="1">if response.StatusCode != 200 </span><span class="cov0" title="0">{
                        return handleError(errMsg + ", with status code: " + strconv.Itoa(response.StatusCode))
                }</span>
                <span class="cov8" title="1">var result dingResponse
                err = request.ToJSON(&amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(errMsg + ", with error: " + err.Error())
                }</span>
                <span class="cov8" title="1">if result.ErrCode != 0 </span><span class="cov0" title="0">{
                        return handleError(errMsg + ", with errmsg: " + result.ErrMsg)
                }</span>
                <span class="cov8" title="1">token := result.AccessToken
                body := make(map[string]interface{})
                dingText := ""
                if isTest </span><span class="cov8" title="1">{
                        dingText = "OpenRASP test message from app: " + app.Name + ", time: " + time.Now().Format(time.RFC3339)
                }</span> else<span class="cov8" title="1"> {
                        panelUrl, _ := getPanelServerUrl()
                        if len(panelUrl) == 0 </span><span class="cov0" title="0">{
                                panelUrl = "http://127.0.0.1"
                        }</span>
                        <span class="cov8" title="1">dingText = "时间：" + time.Now().Format(time.RFC3339) + "， 来自 OpenRAS 的报警\n共有 " +
                                strconv.FormatInt(total, 10) + " 条报警信息来自 APP：" + app.Name + "，详细信息：" +
                                panelUrl + "/#/events/" + app.Id</span>
                }
                <span class="cov8" title="1">if len(dingCong.RecvUser) &gt; 0 </span><span class="cov8" title="1">{
                        body["touser"] = strings.Join(dingCong.RecvUser, "|")
                }</span>
                <span class="cov8" title="1">if len(dingCong.RecvParty) &gt; 0 </span><span class="cov8" title="1">{
                        body["toparty"] = strings.Join(dingCong.RecvParty, "|")
                }</span>
                <span class="cov8" title="1">body["agentid"] = dingCong.AgentId
                body["msgtype"] = "text"
                body["text"] = map[string]string{"content": dingText}
                request = httplib.Post("https://oapi.dingtalk.com/message/send?access_token=" + token)
                request.JSONBody(body)
                request.SetTimeout(10*time.Second, 10*time.Second)
                response, err = request.Response()
                errMsg = "failed to push ding ding alarms with corp id: " + dingCong.CorpId
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(errMsg + ", with error: " + err.Error())
                }</span>
                <span class="cov8" title="1">if response.StatusCode != 200 </span><span class="cov0" title="0">{
                        return handleError(errMsg + ", with status code: " + strconv.Itoa(response.StatusCode))
                }</span>
                <span class="cov8" title="1">err = request.ToJSON(&amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(errMsg + ", with error: " + err.Error())
                }</span>
                <span class="cov8" title="1">if result.ErrCode != 0 </span><span class="cov0" title="0">{
                        return handleError(errMsg + ", with errmsg: " + result.ErrMsg)
                }</span>
        } else<span class="cov0" title="0"> {
                return handleError("failed to send ding ding alarm: invalid ding ding alarm conf")
        }</span>
        <span class="cov8" title="1">beego.Debug("succeed in pushing ding ding alarm for app: " + app.Name + " ,with corp id: " + dingCong.CorpId)
        return nil</span>
}
</pre>

      <pre
        class="file"
        id="file25"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package models

import (
        "time"
        "rasp-cloud/mongo"
        "rasp-cloud/tools"
        "gopkg.in/mgo.v2"
        "rasp-cloud/conf"
        "gopkg.in/mgo.v2/bson"
)

type Cookie struct {
        Id   string    `json:"id" bson:"_id"`
        Time time.Time `json:"time" bson:"time"`
}

const (
        cookieCollectionName = "cookie"
        AuthCookieName       = "RASP_AUTH_ID"
)

func init() <span class="cov8" title="1">{
        index := &amp;mgo.Index{
                Key:         []string{"time"},
                Background:  true,
                Name:        "time",
                ExpireAfter: time.Duration(conf.AppConfig.CookieLifeTime) * time.Hour,
        }
        err := mongo.CreateIndex(cookieCollectionName, index)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeMongoInitFailed, "failed to create index for app collection", err)
        }</span>
}

func NewCookie(id string) error <span class="cov8" title="1">{
        return mongo.Insert(cookieCollectionName, &amp;Cookie{Id: id, Time: time.Now()})
}</span>

func HasCookie(id string) (bool, error) <span class="cov8" title="1">{
        var result *Cookie
        err := mongo.FindId(cookieCollectionName, id, &amp;result)
        if err != nil || result == nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">return true, err</span>
}

func RemoveCookie(id string) error <span class="cov8" title="1">{
        return mongo.RemoveId(cookieCollectionName, id)
}</span>

func RemoveAllCookie() error <span class="cov8" title="1">{
        _, err := mongo.RemoveAll(cookieCollectionName, bson.M{})
        return err
}</span>
</pre>

      <pre
        class="file"
        id="file26"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package logs

import (
        "crypto/md5"
        "fmt"
        "rasp-cloud/es"
        "github.com/olivere/elastic"
        "time"
        "context"
        "github.com/oschwald/geoip2-golang"
        "github.com/astaxie/beego"
        "net"
        "rasp-cloud/tools"
        "encoding/json"
        "rasp-cloud/conf"
)

var (
        AttackAlarmInfo = AlarmLogInfo{
                EsType:       "attack-alarm",
                EsIndex:      "openrasp-attack-alarm",
                EsAliasIndex: "real-openrasp-attack-alarm",
                TtlTime:      24 * 365 * time.Hour,
                AlarmBuffer:  make(chan map[string]interface{}, conf.AppConfig.AlarmBufferSize),
                FileLogger:   initAlarmFileLogger("/openrasp-logs/attack-alarm", "attack.log"),
        }
        geoIpDbPath string
        geoIpDb     *geoip2.Reader

        AttackTypeMap = map[interface{}]string{
                "sql":                        "SQL 注入",
                "sql_exception":              "SQL 语句异常",
                "command":                    "命令执行",
                "xxe":                        "XXE 外部实体加载",
                "directory":                  "目录遍历",
                "rename":                     "文件重命名",
                "readFile":                   "任意文件下载",
                "include":                    "任意文件包含",
                "writeFile":                  "任意文件写入",
                "ssrf":                       "SSRF 服务端请求伪造",
                "ognl":                       "OGNL 代码执行",
                "webdav":                     "任意文件上传 (PUT)",
                "fileUpload":                 "任意文件上传",
                "deserialization":            "Transformer 反序列化",
                "xss_echo":                   "Echo XSS 跨站脚本攻击",
                "xss_userinput":              "BODY XSS 跨站脚本攻击",
                "webshell_callable":          "WebShell - 变形后门",
                "webshell_eval":              "WebShell - 中国菜刀",
                "webshell_command":           "WebShell - 命令执行",
                "webshell_file_put_contents": "WebShell - 后门上传",
                "webshell_ld_preload":        "WebShell - LD_PRELOAD 后门",
        }

        AttackInterceptMap = map[interface{}]string{
                "block": "拦截请求",
                "log":   "记录日志",
        }
)

func init() <span class="cov8" title="1">{
        var err error
        registerAlarmInfo(&amp;AttackAlarmInfo)
        geoIpDbPath = tools.GetCurrentPathWithPanic() + "/geoip/GeoLite2-City.mmdb"
        geoIpDb, err = geoip2.Open(geoIpDbPath)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeGeoipInit, "failed to open geoip database", err)
        }</span>
}

func AddAttackAlarm(alarm map[string]interface{}) error <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        beego.Error("failed to add attack alarm: ", r)
                }</span>
        }()
        <span class="cov8" title="1">if stack, ok := alarm["stack_trace"]; ok &amp;&amp; stack != nil &amp;&amp; stack != "" </span><span class="cov8" title="1">{
                _, ok = stack.(string)
                if ok </span><span class="cov8" title="1">{
                        alarm["stack_md5"] = fmt.Sprintf("%x", md5.Sum([]byte(stack.(string))))
                }</span>
        }
        <span class="cov8" title="1">setAlarmLocation(alarm)
        return AddAlarmFunc(AttackAlarmInfo.EsType, alarm)</span>
}

func setAlarmLocation(alarm map[string]interface{}) <span class="cov8" title="1">{
        if attackSource, ok := alarm["attack_source"]; ok &amp;&amp; attackSource != nil </span><span class="cov8" title="1">{
                _, ok = attackSource.(string)
                if ok </span><span class="cov8" title="1">{
                        attackIp := net.ParseIP(attackSource.(string))
                        record, err := geoIpDb.City(attackIp)
                        if err != nil </span><span class="cov0" title="0">{
                                beego.Error("failed to parse attack ip to location: " + err.Error())
                        }</span>
                        <span class="cov8" title="1">if record != nil </span><span class="cov8" title="1">{
                                alarm["attack_location"] = map[string]interface{}{
                                        "location_zh_cn": record.Country.Names["zh-CN"] + "-" + record.City.Names["zh-CN"],
                                        "location_en":    record.Country.Names["en"] + "-" + record.City.Names["en"],
                                        "latitude":       record.Location.Latitude,
                                        "longitude":      record.Location.Longitude,
                                }
                        }</span>
                }
        }
}

func AggregationAttackWithTime(startTime int64, endTime int64, interval string, timeZone string,
        appId string) (map[string]interface{}, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
        defer cancel()
        timeAggrName := "aggr_time"
        interceptAggrName := "request_sum"
        timeAggr := elastic.NewDateHistogramAggregation().Field("event_time").TimeZone(timeZone).
                Interval(interval).ExtendedBounds(startTime, endTime)
        interceptAggr := elastic.NewTermsAggregation().Field("intercept_state")
        timeAggr.SubAggregation(interceptAggrName, interceptAggr)
        timeQuery := elastic.NewRangeQuery("event_time").Gte(startTime).Lte(endTime)
        aggrResult, err := es.ElasticClient.Search(AttackAlarmInfo.EsAliasIndex + "-" + appId).
                Query(elastic.NewBoolQuery().Must(timeQuery)).
                Aggregation(timeAggrName, timeAggr).
                Size(0).
                Do(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if aggrResult != nil &amp;&amp; aggrResult.Error != nil </span><span class="cov8" title="1">{
                        errMsg, err := json.Marshal(aggrResult.Error)
                        if err != nil </span><span class="cov0" title="0">{
                                beego.Error(string(errMsg))
                        }</span>
                }
                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">var dataResult = make([][]int64, 2)
        dataResult[0] = make([]int64, 0)
        dataResult[1] = make([]int64, 0)
        var labels = make([]interface{}, 0)
        var result = make(map[string]interface{})
        if aggrResult != nil &amp;&amp; aggrResult.Aggregations != nil </span><span class="cov8" title="1">{
                if terms, ok := aggrResult.Aggregations.Terms(timeAggrName); ok &amp;&amp; terms.Buckets != nil </span><span class="cov8" title="1">{
                        labelCount := len(terms.Buckets)
                        dataResult[0] = make([]int64, labelCount)
                        dataResult[1] = make([]int64, labelCount)
                        labels = make([]interface{}, labelCount)
                        for index, timeTerm := range terms.Buckets </span><span class="cov8" title="1">{
                                labels[index] = timeTerm.Key
                                if interceptTerm, ok := timeTerm.Terms(interceptAggrName); ok </span><span class="cov8" title="1">{
                                        for _, item := range interceptTerm.Buckets </span><span class="cov8" title="1">{
                                                if item.Key == "block" </span><span class="cov8" title="1">{
                                                        dataResult[0][index] = item.DocCount
                                                }</span> else<span class="cov0" title="0"> if item.Key == "log" </span><span class="cov0" title="0">{
                                                        dataResult[1][index] = item.DocCount
                                                }</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov8" title="1">result["data"] = dataResult
        result["labels"] = labels
        return result, nil</span>
}

func AggregationAttackWithUserAgent(startTime int64, endTime int64, size int,
        appId string) ([][]interface{}, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
        defer cancel()
        uaAggr := elastic.NewTermsAggregation().Field("user_agent").Size(size).OrderByCount(false)
        timeQuery := elastic.NewRangeQuery("event_time").Gte(startTime).Lte(endTime)
        aggrName := "aggr_ua"
        aggrResult, err := es.ElasticClient.Search(AttackAlarmInfo.EsAliasIndex + "-" + appId).
                Query(timeQuery).
                Aggregation(aggrName, uaAggr).
                Size(0).
                Do(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if aggrResult != nil &amp;&amp; aggrResult.Error != nil </span><span class="cov8" title="1">{
                        errMsg, err := json.Marshal(aggrResult.Error)
                        if err != nil </span><span class="cov0" title="0">{
                                beego.Error(string(errMsg))
                        }</span>
                }
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">result := make([][]interface{}, 0)
        if aggrResult != nil &amp;&amp; aggrResult.Aggregations != nil </span><span class="cov8" title="1">{
                if terms, ok := aggrResult.Aggregations.Terms(aggrName); ok &amp;&amp; terms.Buckets != nil </span><span class="cov8" title="1">{
                        result = make([][]interface{}, len(terms.Buckets))
                        for index, item := range terms.Buckets </span><span class="cov8" title="1">{
                                result[index] = make([]interface{}, 2, 2)
                                result[index][0] = item.Key
                                result[index][1] = item.DocCount
                        }</span>
                }
        }
        <span class="cov8" title="1">return result, nil</span>
}

func AggregationAttackWithType(startTime int64, endTime int64, size int,
        appId string) ([][]interface{}, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
        defer cancel()
        typeAggr := elastic.NewTermsAggregation().Field("attack_type").Size(size).OrderByCount(false)
        timeQuery := elastic.NewRangeQuery("event_time").Gte(startTime).Lte(endTime)
        aggrName := "aggr_type"
        aggrResult, err := es.ElasticClient.Search(AttackAlarmInfo.EsAliasIndex + "-" + appId).
                Query(timeQuery).
                Aggregation(aggrName, typeAggr).
                Size(0).
                Do(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if aggrResult != nil &amp;&amp; aggrResult.Error != nil </span><span class="cov8" title="1">{
                        errMsg, err := json.Marshal(aggrResult.Error)
                        if err != nil </span><span class="cov0" title="0">{
                                beego.Error(string(errMsg))
                        }</span>
                }
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">result := make([][]interface{}, 0)
        if aggrResult != nil &amp;&amp; aggrResult.Aggregations != nil </span><span class="cov8" title="1">{
                if terms, ok := aggrResult.Aggregations.Terms(aggrName); ok &amp;&amp; terms.Buckets != nil </span><span class="cov8" title="1">{
                        result = make([][]interface{}, len(terms.Buckets))
                        for index, item := range terms.Buckets </span><span class="cov8" title="1">{
                                result[index] = make([]interface{}, 2, 2)
                                result[index][0] = item.Key
                                result[index][1] = item.DocCount
                        }</span>
                }
        }
        <span class="cov8" title="1">return result, nil</span>
}
</pre>

      <pre class="file" id="file27" style="display: none">package logs

import (
        "github.com/astaxie/beego"
        "time"
        "rasp-cloud/conf"
)

var (
        ErrorAlarmInfo = AlarmLogInfo{
                EsType:       "error-alarm",
                EsIndex:      "openrasp-error-alarm",
                EsAliasIndex: "real-openrasp-error-alarm",
                TtlTime:      24 * 365 * time.Hour,
                AlarmBuffer:  make(chan map[string]interface{}, conf.AppConfig.AlarmBufferSize),
                FileLogger:   initAlarmFileLogger("/openrasp-logs/error-alarm", "error.log"),
        }
)

func init() <span class="cov8" title="1">{
        registerAlarmInfo(&amp;ErrorAlarmInfo)
}</span>

func AddErrorAlarm(alarm map[string]interface{}) error <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        beego.Error("failed to add error alarm: ", r)
                }</span>
        }()
        <span class="cov8" title="1">return AddAlarmFunc(ErrorAlarmInfo.EsType, alarm)</span>
}
</pre>

      <pre
        class="file"
        id="file28"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package logs

import (
        "context"
        "encoding/json"
        "fmt"
        "github.com/astaxie/beego"
        "github.com/astaxie/beego/logs"
        "github.com/olivere/elastic"
        "os"
        "path"
        "rasp-cloud/es"
        "rasp-cloud/tools"
        "time"
        "rasp-cloud/conf"
)

type AggrTimeParam struct {
        AppId     string `json:"app_id"`
        StartTime int64  `json:"start_time"`
        EndTime   int64  `json:"end_time"`
        Interval  string `json:"interval"`
        TimeZone  string `json:"time_zone"`
}

type AggrFieldParam struct {
        AppId     string `json:"app_id"`
        StartTime int64  `json:"start_time"`
        EndTime   int64  `json:"end_time"`
        Size      int    `json:"size"`
}

type SearchAttackParam struct {
        Page    int `json:"page"`
        Perpage int `json:"perpage"`
        Data *struct {
                Id             string    `json:"_id,omitempty"`
                AppId          string    `json:"app_id,omitempty"`
                StartTime      int64     `json:"start_time"`
                EndTime        int64     `json:"end_time"`
                RaspId         string    `json:"rasp_id,omitempty"`
                HostName       string    `json:"server_hostname,omitempty"`
                AttackSource   string    `json:"attack_source,omitempty"`
                AttackUrl      string    `json:"url,omitempty"`
                LocalIp        string    `json:"local_ip,omitempty"`
                StackMd5       string    `json:"stack_md5,omitempty"`
                AttackType     *[]string `json:"attack_type,omitempty"`
                InterceptState *[]string `json:"intercept_state,omitempty"`
        } `json:"data"`
}

type SearchPolicyParam struct {
        Page    int `json:"page"`
        Perpage int `json:"perpage"`
        Data *struct {
                Id        string    `json:"_id,omitempty"`
                AppId     string    `json:"app_id,omitempty"`
                StartTime int64     `json:"start_time"`
                EndTime   int64     `json:"end_time"`
                RaspId    string    `json:"rasp_id,omitempty"`
                HostName  string    `json:"server_hostname,omitempty"`
                LocalIp   string    `json:"local_ip,omitempty"`
                PolicyId  *[]string `json:"policy_id,omitempty"`
        } `json:"data"`
}

type SearchErrorParam struct {
        Page    int `json:"page"`
        Perpage int `json:"perpage"`
        Data *struct {
                Id        string `json:"_id,omitempty"`
                AppId     string `json:"app_id,omitempty"`
                StartTime int64  `json:"start_time"`
                EndTime   int64  `json:"end_time"`
                RaspId    string `json:"rasp_id,omitempty"`
                HostName  string `json:"server_hostname,omitempty"`
                LocalIp   string `json:"local_ip,omitempty"`
        } `json:"data"`
}

type AlarmLogInfo struct {
        EsType       string
        EsIndex      string
        EsAliasIndex string
        TtlTime      time.Duration
        FileLogger   *logs.BeeLogger
        AlarmBuffer  chan map[string]interface{}
}

var (
        AddAlarmFunc func(string, map[string]interface{}) error
        alarmInfos   = make(map[string]*AlarmLogInfo)
)

func init() <span class="cov8" title="1">{
        if conf.AppConfig.AlarmLogMode == "file" </span><span class="cov0" title="0">{
                AddAlarmFunc = AddLogWithFile
        }</span> else<span class="cov8" title="1"> if conf.AppConfig.AlarmLogMode == "es" </span><span class="cov8" title="1">{
                startEsAlarmLogPush()
                AddAlarmFunc = AddLogWithES
        }</span> else<span class="cov0" title="0"> {
                tools.Panic(tools.ErrCodeConfigInitFailed, "Unrecognized the value of RaspLogMode config", nil)
        }</span>
}

func registerAlarmInfo(info *AlarmLogInfo) <span class="cov8" title="1">{
        alarmInfos[info.EsType] = info
        es.RegisterTTL(info.TtlTime, info.EsAliasIndex+"-*")
}</span>

func initAlarmFileLogger(dirName string, fileName string) *logs.BeeLogger <span class="cov8" title="1">{
        dirName = tools.GetCurrentPathWithPanic() + dirName
        if isExists, _ := tools.PathExists(dirName); !isExists </span><span class="cov0" title="0">{
                err := os.MkdirAll(dirName, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        tools.Panic(tools.ErrCodeLogInitFailed, "failed to init alarm logger", err)
                }</span>
        }

        <span class="cov8" title="1">logger := logs.NewLogger()
        logPath := path.Join(dirName, fileName)
        err := logger.SetLogger(tools.AdapterAlarmFile,
                `{"filename":"`+logPath+`", "daily":true, "maxdays":10, "perm":"0777"}`)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeLogInitFailed, "failed to init alarm logger", err)
        }</span>
        <span class="cov8" title="1">return logger</span>
}

func startEsAlarmLogPush() <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        handleEsLogPush()
                }</span>
        }()
}

func handleEsLogPush() <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        beego.Error("failed to push es alarm log: ", r)
                }</span>
        }()
        <span class="cov8" title="1">select </span>{
        case alarm := &lt;-AttackAlarmInfo.AlarmBuffer:<span class="cov8" title="1">
                alarms := make([]map[string]interface{}, 0, 200)
                alarms = append(alarms, alarm)
                for len(AttackAlarmInfo.AlarmBuffer) &gt; 0 &amp;&amp; len(alarms) &lt; 200 </span><span class="cov0" title="0">{
                        alarm := &lt;-AttackAlarmInfo.AlarmBuffer
                        alarms = append(alarms, alarm)
                }</span>
                <span class="cov8" title="1">err := es.BulkInsert(AttackAlarmInfo.EsType, alarms)
                if err != nil </span><span class="cov0" title="0">{
                        beego.Error("failed to execute es bulk insert for attack alarm: " + err.Error())
                }</span>
        case alarm := &lt;-PolicyAlarmInfo.AlarmBuffer:<span class="cov8" title="1">
                alarms := make([]map[string]interface{}, 0, 200)
                alarms = append(alarms, alarm)
                for len(PolicyAlarmInfo.AlarmBuffer) &gt; 0 &amp;&amp; len(alarms) &lt; 200 </span><span class="cov0" title="0">{
                        alarm := &lt;-PolicyAlarmInfo.AlarmBuffer
                        alarms = append(alarms, alarm)
                }</span>
                <span class="cov8" title="1">err := es.BulkInsert(PolicyAlarmInfo.EsType, alarms)
                if err != nil </span><span class="cov0" title="0">{
                        beego.Error("failed to execute es bulk insert for policy alarm: " + err.Error())
                }</span>
        case alarm := &lt;-ErrorAlarmInfo.AlarmBuffer:<span class="cov8" title="1">
                alarms := make([]map[string]interface{}, 0, 200)
                alarms = append(alarms, alarm)
                for len(ErrorAlarmInfo.AlarmBuffer) &gt; 0 &amp;&amp; len(alarms) &lt; 200 </span><span class="cov0" title="0">{
                        alarm := &lt;-ErrorAlarmInfo.AlarmBuffer
                        alarms = append(alarms, alarm)
                }</span>
                <span class="cov8" title="1">err := es.BulkInsert(ErrorAlarmInfo.EsType, alarms)
                if err != nil </span><span class="cov0" title="0">{
                        beego.Error("failed to execute es bulk insert for error alarm: " + err.Error())
                }</span>
        }
}

func AddLogWithFile(alarmType string, alarm map[string]interface{}) error <span class="cov8" title="1">{
        if info, ok := alarmInfos[alarmType]; ok &amp;&amp; info.FileLogger != nil </span><span class="cov8" title="1">{
                content, err := json.Marshal(alarm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">_, err = info.FileLogger.Write(content)
                if err != nil </span><span class="cov0" title="0">{
                        logs.Error("failed to write rasp log: " + err.Error())
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                logs.Error("failed to write rasp log, unrecognized log type: " + alarmType)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func AddLogWithES(alarmType string, alarm map[string]interface{}) error <span class="cov8" title="1">{
        select </span>{
        case alarmInfos[alarmType].AlarmBuffer &lt;- alarm:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0">
                logs.Error("Failed to write attack alarm to ES, " +
                        "the buffer is full. Consider increase AlarmBufferSize value: " + fmt.Sprintf("%+v", alarm))</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func getVulnAggr(attackTimeTopHitName string) (*elastic.TermsAggregation) <span class="cov8" title="1">{
        attackMaxAggrName := "attack_max_aggr"
        attackTimeTopHitAggr := elastic.NewTopHitsAggregation().
                Size(1).
                Sort("event_time", false).
                DocvalueFields("event_time", "attack_type", "intercept_state", "url",
                "path", "rasp_id", "attack_source", "plugin_algorithm", "server_ip", "server_hostname")
        attackTimeMaxAggr := elastic.NewMaxAggregation().Field("event_time")
        return elastic.NewTermsAggregation().
                Field("stack_md5").
                Size(10000).
                Order(attackMaxAggrName, false).
                SubAggregation(attackMaxAggrName, attackTimeMaxAggr).
                SubAggregation(attackTimeTopHitName, attackTimeTopHitAggr)
}</span>

func SearchLogs(startTime int64, endTime int64, isAttachAggr bool, query map[string]interface{}, sortField string,
        page int, perpage int, ascending bool, index ...string) (int64, []map[string]interface{}, error) <span class="cov8" title="1">{
        var total int64
        var attackAggrName = "attack_aggr"
        var attackTimeTopHitName = "attack_time_top_hit"
        filterQueries := make([]elastic.Query, 0, len(query)+1)
        shouldQueries := make([]elastic.Query, 0, len(query)+1)
        if query != nil </span><span class="cov8" title="1">{
                for key, value := range query </span><span class="cov8" title="1">{
                        if key == "attack_type" </span><span class="cov8" title="1">{
                                if v, ok := value.([]interface{}); ok </span><span class="cov8" title="1">{
                                        filterQueries = append(filterQueries, elastic.NewTermsQuery(key, v...))
                                }</span> else<span class="cov0" title="0"> {
                                        filterQueries = append(filterQueries, elastic.NewTermQuery(key, value))
                                }</span>
                        } else<span class="cov8" title="1"> if key == "intercept_state" </span><span class="cov8" title="1">{
                                if v, ok := value.([]interface{}); ok </span><span class="cov8" title="1">{
                                        filterQueries = append(filterQueries, elastic.NewTermsQuery(key, v...))
                                }</span> else<span class="cov0" title="0"> {
                                        filterQueries = append(filterQueries, elastic.NewTermQuery(key, value))
                                }</span>
                        } else<span class="cov8" title="1"> if key == "policy_id" </span><span class="cov8" title="1">{
                                if v, ok := value.([]interface{}); ok </span><span class="cov8" title="1">{
                                        filterQueries = append(filterQueries, elastic.NewTermsQuery(key, v...))
                                }</span> else<span class="cov0" title="0"> {
                                        filterQueries = append(filterQueries, elastic.NewTermQuery(key, value))
                                }</span>
                        } else<span class="cov8" title="1"> if key == "local_ip" </span><span class="cov8" title="1">{
                                filterQueries = append(filterQueries,
                                        elastic.NewNestedQuery("server_nic", elastic.NewTermQuery("server_nic.ip", value)))
                        }</span> else<span class="cov8" title="1"> if key == "attack_source" </span><span class="cov8" title="1">{
                                filterQueries = append(filterQueries, elastic.NewWildcardQuery(key, "*"+fmt.Sprint(value)+"*"))
                        }</span> else<span class="cov8" title="1"> if key == "server_hostname" </span><span class="cov8" title="1">{
                                shouldQueries = append(shouldQueries,
                                        elastic.NewWildcardQuery("server_hostname", "*"+fmt.Sprint(value)+"*"))
                                shouldQueries = append(shouldQueries,
                                        elastic.NewNestedQuery("server_nic",
                                                elastic.NewWildcardQuery("server_nic.ip", "*"+fmt.Sprint(value)+"*")))
                        }</span> else<span class="cov0" title="0"> if key == "url" </span><span class="cov0" title="0">{
                                filterQueries = append(filterQueries,
                                        elastic.NewWildcardQuery("url", "*"+fmt.Sprint(value)+"*"))
                        }</span> else<span class="cov0" title="0"> {
                                filterQueries = append(filterQueries, elastic.NewTermQuery(key, value))
                        }</span>
                }
        }
        <span class="cov8" title="1">filterQueries = append(filterQueries, elastic.NewRangeQuery("event_time").Gte(startTime).Lte(endTime))
        ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(15*time.Second))
        defer cancel()
        boolQuery := elastic.NewBoolQuery().Filter(filterQueries...)
        if len(shouldQueries) &gt; 0 </span><span class="cov8" title="1">{
                boolQuery.Should(shouldQueries...).MinimumNumberShouldMatch(1)
        }</span>

        <span class="cov8" title="1">queryService := es.ElasticClient.Search(index...).Query(boolQuery)

        if isAttachAggr </span><span class="cov8" title="1">{
                attackAggr := getVulnAggr(attackTimeTopHitName)
                queryService.Aggregation(attackAggrName, attackAggr).Size(0)
        }</span> else<span class="cov8" title="1"> {
                queryService.From((page - 1) * perpage).Size(perpage).Sort(sortField, ascending)
        }</span>

        <span class="cov8" title="1">queryResult, err := queryService.Do(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if queryResult != nil &amp;&amp; queryResult.Error != nil </span><span class="cov0" title="0">{
                        beego.Error(queryResult.Error, index)
                }</span>
                <span class="cov0" title="0">return 0, nil, err</span>
        }

        <span class="cov8" title="1">result := make([]map[string]interface{}, 0)
        if !isAttachAggr </span><span class="cov8" title="1">{
                if queryResult != nil &amp;&amp; queryResult.Hits != nil &amp;&amp; queryResult.Hits.Hits != nil </span><span class="cov8" title="1">{
                        hits := queryResult.Hits.Hits
                        total = queryResult.Hits.TotalHits
                        result = make([]map[string]interface{}, len(hits))
                        for index, item := range hits </span><span class="cov8" title="1">{
                                result[index] = make(map[string]interface{})
                                err := json.Unmarshal(*item.Source, &amp;result[index])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, nil, err
                                }</span>
                                <span class="cov8" title="1">result[index]["id"] = item.Id
                                delete(result[index], "_@timestamp")
                                delete(result[index], "@timestamp")
                                delete(result[index], "@version")
                                delete(result[index], "tags")
                                delete(result[index], "host")</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                if queryResult != nil &amp;&amp; queryResult.Aggregations != nil </span><span class="cov8" title="1">{
                        if terms, ok := queryResult.Aggregations.Terms(attackAggrName); ok &amp;&amp; terms.Buckets != nil </span><span class="cov8" title="1">{
                                total = int64(len(terms.Buckets))
                                result = make([]map[string]interface{}, 0, perpage)
                                for i := 0; i &lt; perpage; i++ </span><span class="cov8" title="1">{
                                        index := i + (page-1)*perpage
                                        if index &gt;= int(total) </span><span class="cov8" title="1">{
                                                break</span>
                                        }
                                        <span class="cov8" title="1">value := make(map[string]interface{})
                                        item := terms.Buckets[index]
                                        if topHit, ok := item.TopHits(attackTimeTopHitName); ok &amp;&amp;
                                                topHit.Hits != nil &amp;&amp; topHit.Hits.Hits != nil </span><span class="cov8" title="1">{
                                                hits := topHit.Hits.Hits
                                                if len(hits) &gt; 0 </span><span class="cov8" title="1">{
                                                        err := json.Unmarshal(*hits[0].Source, &amp;value)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return 0, nil, err
                                                        }</span>
                                                        <span class="cov8" title="1">value["id"] = hits[0].Id
                                                        value["attack_count"] = terms.Buckets[index].DocCount
                                                        result = append(result, value)</span>
                                                }
                                        }
                                }
                        }

                }
        }

        <span class="cov8" title="1">return total, result, nil</span>
}

func CreateAlarmEsIndex(appId string) (err error) <span class="cov8" title="1">{
        for _, alarmInfo := range alarmInfos </span><span class="cov8" title="1">{
                err = es.CreateEsIndex(alarmInfo.EsIndex + "-" + appId)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>

      <pre
        class="file"
        id="file29"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package logs

import (
        "fmt"
        "crypto/md5"
        "github.com/astaxie/beego"
        "time"
        "rasp-cloud/conf"
)

var (
        PolicyAlarmInfo = AlarmLogInfo{
                EsType:       "policy-alarm",
                EsIndex:      "openrasp-policy-alarm",
                EsAliasIndex: "real-openrasp-policy-alarm",
                TtlTime:      24 * 365 * time.Hour,
                AlarmBuffer:  make(chan map[string]interface{}, conf.AppConfig.AlarmBufferSize),
                FileLogger:   initAlarmFileLogger("/openrasp-logs/policy-alarm", "policy.log"),
        }
)

func init() <span class="cov8" title="1">{
        registerAlarmInfo(&amp;PolicyAlarmInfo)
}</span>

func AddPolicyAlarm(alarm map[string]interface{}) error <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        beego.Error("failed to add policy alarm: ", r)
                }</span>
        }()
        <span class="cov8" title="1">if stack, ok := alarm["stack_trace"]; ok &amp;&amp; stack != nil &amp;&amp; stack != "" </span><span class="cov8" title="1">{
                _, ok = stack.(string)
                if ok </span><span class="cov8" title="1">{
                        alarm["stack_md5"] = fmt.Sprintf("%x", md5.Sum([]byte(stack.(string))))
                }</span>
        }
        <span class="cov8" title="1">idContent := ""
        idContent += fmt.Sprint(alarm["rasp_id"])
        idContent += fmt.Sprint(alarm["policy_id"])
        idContent += fmt.Sprint(alarm["stack_md5"])
        if alarm["policy_id"] == "3007" &amp;&amp; alarm["policy_params"] != nil </span><span class="cov0" title="0">{
                if policyParam, ok := alarm["policy_params"].(map[string]interface{}); ok &amp;&amp; len(policyParam) &gt; 0 </span><span class="cov0" title="0">{
                        idContent += fmt.Sprint(policyParam["type"])
                }</span>
        } else<span class="cov8" title="1"> if alarm["policy_id"] == "3006" &amp;&amp; alarm["policy_params"] != nil </span><span class="cov8" title="1">{
                if policyParam, ok := alarm["policy_params"].(map[string]interface{}); ok &amp;&amp; len(policyParam) &gt; 0 </span><span class="cov8" title="1">{
                        idContent += fmt.Sprint(policyParam["connectionString"])
                        idContent += fmt.Sprint(policyParam["port"])
                        idContent += fmt.Sprint(policyParam["server"])
                        idContent += fmt.Sprint(policyParam["hostname"])
                        idContent += fmt.Sprint(policyParam["socket"])
                        idContent += fmt.Sprint(policyParam["username"])
                }</span>
        }
        <span class="cov8" title="1">alarm["upsert_id"] = fmt.Sprintf("%x", md5.Sum([]byte(idContent)))
        return AddAlarmFunc(PolicyAlarmInfo.EsType, alarm)</span>
}
</pre>

      <pre
        class="file"
        id="file30"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package models

import (
        "rasp-cloud/mongo"
        "gopkg.in/mgo.v2/bson"
        "rasp-cloud/tools"
        "github.com/astaxie/beego"
        "gopkg.in/mgo.v2"
        "strconv"
        "time"
        "math/rand"
        "fmt"
        "crypto/sha1"
)

// operations about app
type Operation struct {
        Id      string `json:"id" bson:"_id,omitempty"`
        TypeId  int    `json:"type_id" bson:"type_id,omitempty"`
        AppId   string `json:"app_id" bson:"app_id,omitempty"`
        Time    int64  `json:"time" bson:"time,omitempty"`
        User    string `json:"user" bson:"user,omitempty"`
        Content string `json:"content" bson:"content,omitempty"`
        Ip      string `json:"ip" bson:"ip,omitempty"`
}

const (
        operationCollectionName = "operation"

        OperationTypeRegisterRasp          = 1001 + iota
        OperationTypeDeleteRasp
        OperationTypeRegenerateSecret
        OperationTypeUpdateGenerateConfig
        OperationTypeUpdateWhitelistConfig
        OperationTypeUpdateAlgorithmConfig
        OperationTypeUpdateAlarmConfig
        OperationTypeSetSelectedPlugin
        OperationTypeUploadPlugin
        OperationTypeDeletePlugin
        OperationTypeAddApp
        OperationTypeDeleteApp
        OperationTypeEditApp
        OperationTypeRestorePlugin
)

func init() <span class="cov8" title="1">{
        index := &amp;mgo.Index{
                Key:        []string{"app_id"},
                Unique:     false,
                Background: true,
                Name:       "app_id",
        }
        err := mongo.CreateIndex(operationCollectionName, index)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeConfigInitFailed,
                        "failed to create app_id index for operation collection", err)
        }</span>

        <span class="cov8" title="1">index = &amp;mgo.Index{
                Key:        []string{"time"},
                Unique:     false,
                Background: true,
                Name:       "time",
        }
        err = mongo.CreateIndex(operationCollectionName, index)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeConfigInitFailed,
                        "failed to create operate_time index for operation collection", err)
        }</span>

}

func AddOperation(appId string, typeId int, ip string, content string, userName ...string) error <span class="cov8" title="1">{
        var user string
        var err error
        if len(userName) == 0 </span><span class="cov8" title="1">{
                user, err = GetLoginUserName()
                if err != nil </span><span class="cov8" title="1">{
                        beego.Error("failed to add operation with content: " + content + ",can not get username: " + err.Error())
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                user = userName[0]
        }</span>

        <span class="cov8" title="1">var operation = &amp;Operation{
                AppId:   appId,
                TypeId:  typeId,
                Ip:      ip,
                Id:      generateOperationId(),
                User:    user,
                Time:    time.Now().UnixNano() / 1000000,
                Content: content,
        }
        err = mongo.Insert(operationCollectionName, operation)
        if err != nil </span><span class="cov8" title="1">{
                beego.Error("failed to add operation with content: " + operation.Content + ",error is: " + err.Error())
        }</span>
        <span class="cov8" title="1">return err</span>
}

func generateOperationId() string <span class="cov8" title="1">{
        random := string(bson.NewObjectId()) + strconv.FormatInt(time.Now().UnixNano(), 10) +
                strconv.Itoa(rand.Intn(10000))
        return fmt.Sprintf("%x", sha1.Sum([]byte(random)))
}</span>

func FindOperation(data *Operation, startTime int64, endTime int64,
        page int, perpage int) (count int, result []Operation, err error) <span class="cov8" title="1">{
        searchData := bson.M{}
        if data.Ip != "" </span><span class="cov8" title="1">{
                searchData["ip"] = data.Ip
        }</span>
        <span class="cov8" title="1">if data.AppId != "" </span><span class="cov8" title="1">{
                searchData["app_id"] = data.AppId
        }</span>
        <span class="cov8" title="1">if data.User != "" </span><span class="cov8" title="1">{
                searchData["user"] = data.User
        }</span>
        <span class="cov8" title="1">if data.TypeId != 0 </span><span class="cov8" title="1">{
                searchData["type_id"] = data.TypeId
        }</span>
        <span class="cov8" title="1">if data.Id != "" </span><span class="cov8" title="1">{
                searchData["_id"] = data.Id
        }</span>
        <span class="cov8" title="1">searchData["time"] = bson.M{"$gte": startTime, "$lte": endTime}
        count, err = mongo.FindAll(operationCollectionName, searchData, &amp;result, perpage*(page-1), perpage, "-time")
        if result == nil </span><span class="cov8" title="1">{
                result = make([]Operation, 0)
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>

      <pre
        class="file"
        id="file31"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package models

import (
        "fmt"
        "crypto/md5"
        "rasp-cloud/mongo"
        "gopkg.in/mgo.v2/bson"
        "sync"
        "time"
        "regexp"
        "encoding/json"
        "errors"
        "strconv"
        "math/rand"
        "crypto/sha1"
        "rasp-cloud/tools"
        "gopkg.in/mgo.v2"
        "bufio"
        "bytes"
        "github.com/robertkrimen/otto"
        "rasp-cloud/conf"
)

type Plugin struct {
        Id                     string                 `json:"id" bson:"_id,omitempty"`
        AppId                  string                 `json:"app_id" bson:"app_id"`
        Name                   string                 `json:"name" bson:"name"`
        UploadTime             int64                  `json:"upload_time" bson:"upload_time"`
        Version                string                 `json:"version" bson:"version"`
        Md5                    string                 `json:"md5" bson:"md5"`
        OriginContent          string                 `json:"origin_content" bson:"origin_content"`
        Content                string                 `json:"plugin,omitempty" bson:"content"`
        DefaultAlgorithmConfig map[string]interface{} `json:"-" bson:"default_algorithm_config"`
        AlgorithmConfig        map[string]interface{} `json:"algorithm_config" bson:"algorithm_config"`
}

const (
        pluginCollectionName = "plugin"
)

var (
        mutex sync.Mutex
)

func init() <span class="cov8" title="1">{
        index := &amp;mgo.Index{
                Key:        []string{"app_id"},
                Unique:     false,
                Background: true,
                Name:       "app_id",
        }
        err := mongo.CreateIndex(pluginCollectionName, index)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeMongoInitFailed,
                        "failed to create app_id index for plugin collection", err)
        }</span>
        <span class="cov8" title="1">index = &amp;mgo.Index{
                Key:        []string{"upload_time"},
                Unique:     false,
                Background: true,
                Name:       "upload_time",
        }
        err = mongo.CreateIndex(pluginCollectionName, index)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeMongoInitFailed,
                        "failed to create upload_time index for plugin collection", err)
        }</span>
}

func AddPlugin(pluginContent []byte, appId string) (plugin *Plugin, err error) <span class="cov8" title="1">{
        plugin, err = generatePlugin(pluginContent, appId)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">err = addPluginToDb(plugin)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return</span>
}

func generatePlugin(pluginContent []byte, appId string) (plugin *Plugin, err error) <span class="cov8" title="1">{
        pluginReader := bufio.NewReader(bytes.NewReader(pluginContent))
        firstLine, err := pluginReader.ReadString('\n')
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("failed to read the plugin file: " + err.Error())
        }</span>
        <span class="cov8" title="1">secondLine, err := pluginReader.ReadString('\n')
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("failed to read the plugin file: " + err.Error())
        }</span>
        <span class="cov8" title="1">var newVersion string
        var newPluginName string
        if newVersion = regexp.MustCompile(`'.+'|".+"`).FindString(firstLine); newVersion == "" </span><span class="cov0" title="0">{
                return nil, errors.New("failed to find the plugin version")
        }</span>
        <span class="cov8" title="1">newVersion = newVersion[1 : len(newVersion)-1]
        if newPluginName = regexp.MustCompile(`'.+'|".+"`).FindString(secondLine); newPluginName == "" </span><span class="cov8" title="1">{
                return nil, errors.New("failed to find the plugin name")
        }</span>
        <span class="cov8" title="1">newPluginName = newPluginName[1 : len(newPluginName)-1]
        algorithmStartMsg := "// BEGIN ALGORITHM CONFIG //"
        algorithmEndMsg := "// END ALGORITHM CONFIG //"
        algorithmStart := bytes.Index(pluginContent, []byte(algorithmStartMsg))
        if algorithmStart &lt; 0 </span><span class="cov8" title="1">{
                return nil, errors.New("failed to find the start of algorithmConfig variable: " + algorithmStartMsg)
        }</span>
        <span class="cov8" title="1">algorithmStart = algorithmStart + len([]byte(algorithmStartMsg))
        algorithmEnd := bytes.Index(pluginContent, []byte(algorithmEndMsg))
        if algorithmEnd &lt; 0 </span><span class="cov8" title="1">{
                return nil, errors.New("failed to find the end of algorithmConfig variable: " + algorithmEndMsg)
        }</span>
        <span class="cov8" title="1">jsVm := otto.New()
        _, err = jsVm.Run(string(pluginContent[algorithmStart:algorithmEnd]) +
                "\n algorithmContent=JSON.stringify(algorithmConfig)")
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("failed to get algorithm config from plugin: " + err.Error())
        }</span>
        <span class="cov8" title="1">algorithmContent, err := jsVm.Get("algorithmContent")
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to get algorithm config from plugin: " + err.Error())
        }</span>
        <span class="cov8" title="1">var algorithmData map[string]interface{}
        err = json.Unmarshal([]byte(algorithmContent.String()), &amp;algorithmData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to unmarshal algorithm json data: " + err.Error())
        }</span>
        <span class="cov8" title="1">newMd5 := fmt.Sprintf("%x", md5.Sum(pluginContent))
        plugin = &amp;Plugin{
                Id:                     generatePluginId(appId),
                Version:                newVersion,
                Name:                   newPluginName,
                Md5:                    newMd5,
                OriginContent:          string(pluginContent),
                Content:                string(pluginContent),
                UploadTime:             time.Now().UnixNano() / 1000000,
                AppId:                  appId,
                DefaultAlgorithmConfig: algorithmData,
                AlgorithmConfig:        algorithmData,
        }
        return plugin, nil</span>
}

func addPluginToDb(plugin *Plugin) (err error) <span class="cov8" title="1">{
        mutex.Lock()
        defer mutex.Unlock()

        var count int
        if conf.AppConfig.MaxPlugins &gt; 0 </span><span class="cov8" title="1">{
                _, oldPlugins, err := GetPluginsByApp(plugin.AppId, conf.AppConfig.MaxPlugins-1, 0)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">count = len(oldPlugins)
                if count &gt; 0 </span><span class="cov8" title="1">{
                        for _, oldPlugin := range oldPlugins </span><span class="cov8" title="1">{
                                app := &amp;App{}
                                err = mongo.FindOne("app", bson.M{"selected_plugin_id": oldPlugin.Id}, app)
                                if err != nil &amp;&amp; err != mgo.ErrNotFound </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if app != nil </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">err = mongo.RemoveId(pluginCollectionName, oldPlugin.Id)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">err = mongo.Insert(pluginCollectionName, plugin)
        return</span>
}

func generatePluginId(appId string) string <span class="cov8" title="1">{
        random := string(bson.NewObjectId()) + appId +
                strconv.FormatInt(time.Now().UnixNano(), 10) + strconv.Itoa(rand.Intn(10000))
        return fmt.Sprintf("%x", sha1.Sum([]byte(random)))
}</span>

func GetSelectedPlugin(appId string, hasContent bool) (plugin *Plugin, err error) <span class="cov8" title="1">{
        var app *App
        if err = mongo.FindId(appCollectionName, appId, &amp;app); err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("can not get app," + err.Error())
        }</span>
        <span class="cov8" title="1">return GetPluginById(app.SelectedPluginId, hasContent)</span>
}

func SetSelectedPlugin(appId string, pluginId string) (plugin *Plugin, err error) <span class="cov8" title="1">{
        plugin, err = GetPluginById(pluginId, false)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return plugin, mongo.UpdateId(appCollectionName, appId, bson.M{"selected_plugin_id": pluginId})</span>
}

func RestoreDefaultConfiguration(pluginId string) (appId string, err error) <span class="cov8" title="1">{
        plugin, err := GetPluginById(pluginId, true)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return handleAlgorithmConfig(plugin, plugin.DefaultAlgorithmConfig)</span>
}

func UpdateAlgorithmConfig(pluginId string, config map[string]interface{}) (appId string, err error) <span class="cov8" title="1">{
        plugin, err := GetPluginById(pluginId, true)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if err := validAlgorithmConfig(plugin, config); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return handleAlgorithmConfig(plugin, config)</span>
}

func validAlgorithmConfig(plugin *Plugin, config map[string]interface{}) error <span class="cov8" title="1">{
        errMsg := "failed to match the new config format to default algorithm config format"
        for key, defaultValue := range plugin.DefaultAlgorithmConfig </span><span class="cov8" title="1">{
                if c, ok := config[key]; !ok || (c == nil &amp;&amp; defaultValue != nil) </span><span class="cov8" title="1">{
                        return errors.New(errMsg + ", " + "can not find the key '" + key + "' in new config")
                }</span>
                <span class="cov8" title="1">if defaultValue != nil </span><span class="cov8" title="1">{
                        if defaultItem, ok := defaultValue.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if item, ok := config[key].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                        for subKey := range defaultItem </span><span class="cov8" title="1">{
                                                if _, ok := item[subKey]; !ok </span><span class="cov0" title="0">{
                                                        return errors.New(errMsg + ", " + "can not find the key '" +
                                                                key + "." + subKey + "' in new config")
                                                }</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        return errors.New(errMsg + ", " + "the key '" + key + "' must be an object")
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func handleAlgorithmConfig(plugin *Plugin, config map[string]interface{}) (appId string, err error) <span class="cov8" title="1">{
        content, err := json.MarshalIndent(config, "", "\t")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">regex := `//\s*BEGIN\s*ALGORITHM\s*CONFIG\s*//[\W\w]*?//\s*END\s*ALGORITHM\s*CONFIG\s*//`
        newContent := "// BEGIN ALGORITHM CONFIG //\n\n" +
                "var algorithmConfig = " +
                string(content) + "\n\n// END ALGORITHM CONFIG //"
        if variable := regexp.MustCompile(regex).
                FindString(plugin.Content); len(variable) &lt;= 0 </span><span class="cov0" title="0">{
                return "", errors.New("failed to find algorithmConfig variable")
        }</span>
        <span class="cov8" title="1">algorithmContent := regexp.MustCompile(regex).ReplaceAllString(plugin.Content, newContent)
        newMd5 := fmt.Sprintf("%x", md5.Sum([]byte(algorithmContent)))
        return plugin.AppId, mongo.UpdateId(pluginCollectionName, plugin.Id, bson.M{"content": algorithmContent,
                "algorithm_config": config, "md5": newMd5})</span>
}

func GetPluginById(id string, hasContent bool) (plugin *Plugin, err error) <span class="cov8" title="1">{
        newSession := mongo.NewSession()
        defer newSession.Close()
        query := newSession.DB(mongo.DbName).C(pluginCollectionName).FindId(id)
        if hasContent </span><span class="cov8" title="1">{
                err = query.One(&amp;plugin)
        }</span> else<span class="cov8" title="1"> {
                err = query.Select(bson.M{"content": 0}).One(&amp;plugin)
        }</span>
        <span class="cov8" title="1">return</span>
}

func GetPluginsByApp(appId string, skip int, limit int) (total int, plugins []Plugin, err error) <span class="cov8" title="1">{
        newSession := mongo.NewSession()
        defer newSession.Close()
        total, err = newSession.DB(mongo.DbName).C(pluginCollectionName).Find(bson.M{"app_id": appId}).Count()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">err = newSession.DB(mongo.DbName).C(pluginCollectionName).Find(bson.M{"app_id": appId}).Select(bson.M{"content": 0}).
                Sort("-upload_time").Skip(skip).Limit(limit).All(&amp;plugins)
        if plugins == nil </span><span class="cov8" title="1">{
                plugins = make([]Plugin, 0)
        }</span>
        <span class="cov8" title="1">return</span>
}

func DeletePlugin(pluginId string) error <span class="cov8" title="1">{
        mutex.Lock()
        defer mutex.Unlock()
        return mongo.RemoveId(pluginCollectionName, pluginId)
}</span>

func RemovePluginByAppId(appId string) error <span class="cov8" title="1">{
        _, err := mongo.RemoveAll(pluginCollectionName, bson.M{"app_id": appId})
        return err
}</span>
</pre>

      <pre
        class="file"
        id="file32"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package models

import (
        "rasp-cloud/mongo"
        "rasp-cloud/tools"
        "gopkg.in/mgo.v2"
        "gopkg.in/mgo.v2/bson"
        "time"
        "strconv"
        "errors"
        "github.com/astaxie/beego/httplib"
)

type Rasp struct {
        Id                string            `json:"id" bson:"_id,omitempty"`
        AppId             string            `json:"app_id" bson:"app_id,omitempty"`
        Version           string            `json:"version" bson:"version,omitempty"`
        HostName          string            `json:"hostname" bson:"hostname,omitempty"`
        RegisterIp        string            `json:"register_ip" bson:"register_ip,omitempty"`
        Language          string            `json:"language" bson:"language,omitempty"`
        LanguageVersion   string            `json:"language_version" bson:"language_version,omitempty"`
        ServerType        string            `json:"server_type" bson:"server_type,omitempty"`
        ServerVersion     string            `json:"server_version" bson:"server_version,omitempty"`
        RaspHome          string            `json:"rasp_home" bson:"rasp_home,omitempty"`
        PluginVersion     string            `json:"plugin_version" bson:"plugin_version,omitempty"`
        HeartbeatInterval int64             `json:"heartbeat_interval" bson:"heartbeat_interval,omitempty"`
        Online            *bool             `json:"online" bson:"online,omitempty"`
        LastHeartbeatTime int64             `json:"last_heartbeat_time" bson:"last_heartbeat_time,omitempty"`
        RegisterTime      int64             `json:"register_time" bson:"register_time,omitempty"`
        Environ           map[string]string `json:"environ" bson:"environ,omitempty"`
}

const (
        raspCollectionName = "rasp"
)

func init() <span class="cov8" title="1">{
        index := &amp;mgo.Index{
                Key:        []string{"app_id"},
                Unique:     false,
                Background: true,
                Name:       "app_id",
        }
        err := mongo.CreateIndex(raspCollectionName, index)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeMongoInitFailed,
                        "failed to create app_id index for rasp collection", err)
        }</span>
        <span class="cov8" title="1">index = &amp;mgo.Index{
                Key:        []string{"register_time"},
                Unique:     false,
                Background: true,
                Name:       "register_time",
        }
        err = mongo.CreateIndex(raspCollectionName, index)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeMongoInitFailed,
                        "failed to create register_time index for rasp collection", err)
        }</span>
}

func UpsertRaspById(id string, rasp *Rasp) (error) <span class="cov8" title="1">{
        return mongo.UpsertId(raspCollectionName, id, rasp)
}</span>

func GetRaspByAppId(id string, page int, perpage int) (count int, result []*Rasp, err error) <span class="cov8" title="1">{
        count, err = mongo.FindAll(raspCollectionName, bson.M{"app_id": id}, &amp;result, perpage*(page-1), perpage)
        if err == nil </span><span class="cov8" title="1">{
                for _, rasp := range result </span><span class="cov8" title="1">{
                        HandleRasp(rasp)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func RemoveRaspByAppId(appId string) (err error) <span class="cov8" title="1">{
        _, err = mongo.RemoveAll(raspCollectionName, bson.M{"app_id": appId})
        return
}</span>

func FindRasp(selector *Rasp, page int, perpage int) (count int, result []*Rasp, err error) <span class="cov8" title="1">{
        var bsonContent []byte
        bsonContent, err = bson.Marshal(selector)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">bsonModel := bson.M{}
        err = bson.Unmarshal(bsonContent, &amp;bsonModel)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if bsonModel["hostname"] != nil </span><span class="cov8" title="1">{
                bsonModel["$or"] = []bson.M{
                        {
                                "hostname": bson.M{
                                        "$regex":   bsonModel["hostname"],
                                        "$options": "$i",
                                },
                        },
                        {
                                "register_ip": bson.M{
                                        "$regex":   bsonModel["hostname"],
                                        "$options": "$i",
                                },
                        },
                }
                delete(bsonModel, "hostname")
        }</span>
        <span class="cov8" title="1">if selector.Online != nil </span><span class="cov8" title="1">{
                delete(bsonModel, "online")
                if *selector.Online </span><span class="cov0" title="0">{
                        bsonModel["$where"] = "this.last_heartbeat_time+this.heartbeat_interval+180 &gt;= " +
                                strconv.FormatInt(time.Now().Unix(), 10)
                }</span> else<span class="cov8" title="1"> {
                        bsonModel["$where"] = "this.last_heartbeat_time+this.heartbeat_interval+180 &lt; " +
                                strconv.FormatInt(time.Now().Unix(), 10)
                }</span>
        }
        <span class="cov8" title="1">count, err = mongo.FindAllBySort(raspCollectionName, bsonModel, perpage*(page-1), perpage,
                &amp;result, "-register_time")
        if err == nil </span><span class="cov8" title="1">{
                for _, rasp := range result </span><span class="cov0" title="0">{
                        if selector.Online != nil </span><span class="cov0" title="0">{
                                rasp.Online = selector.Online
                        }</span> else<span class="cov0" title="0"> {
                                HandleRasp(rasp)
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func GetRaspById(id string) (rasp *Rasp, err error) <span class="cov8" title="1">{
        err = mongo.FindId(raspCollectionName, id, &amp;rasp)
        if err == nil </span><span class="cov8" title="1">{
                HandleRasp(rasp)
        }</span>
        <span class="cov8" title="1">return</span>
}

func HandleRasp(rasp *Rasp) <span class="cov8" title="1">{
        var online bool
        heartbeatInterval := rasp.HeartbeatInterval + 180
        if time.Now().Unix()-rasp.LastHeartbeatTime &gt; heartbeatInterval </span><span class="cov0" title="0">{
                online = false
        }</span> else<span class="cov8" title="1"> {
                online = true
        }</span>
        <span class="cov8" title="1">rasp.Online = &amp;online
        if rasp.Environ == nil </span><span class="cov8" title="1">{
                rasp.Environ = map[string]string{}
        }</span>
}

func RemoveRaspById(id string) (err error) <span class="cov8" title="1">{
        rasp, err := GetRaspById(id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if *rasp.Online </span><span class="cov8" title="1">{
                return errors.New("unable to delete online rasp")
        }</span>
        <span class="cov0" title="0">return mongo.RemoveId(raspCollectionName, id)</span>
}

func RemoveRaspBySelector(selector map[string]interface{}, appId string) (int, error) <span class="cov8" title="1">{
        offlineWhere := ""
        if _, ok := selector["expire_time"]; ok </span><span class="cov8" title="1">{
                expireTime := strconv.FormatInt(selector["expire_time"].(int64), 10)
                offlineWhere = "this.last_heartbeat_time+this.heartbeat_interval+180+" + expireTime + "&lt;" +
                        strconv.FormatInt(time.Now().Unix(), 10)
        }</span> else<span class="cov0" title="0"> {
                offlineWhere = "this.last_heartbeat_time+this.heartbeat_interval+180 &lt; " +
                        strconv.FormatInt(time.Now().Unix(), 10)
        }</span>
        <span class="cov8" title="1">param := bson.M{"app_id": appId, "$where": offlineWhere}
        if selector["register_ip"] != nil &amp;&amp; selector["register_ip"] != "" </span><span class="cov8" title="1">{
                param["register_ip"] = selector["register_ip"]
        }</span>
        <span class="cov8" title="1">info, err := mongo.RemoveAll(raspCollectionName, param)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return info.Removed, nil</span>
}

func RegisterCallback(url string, token string, rasp *Rasp) error <span class="cov8" title="1">{
        var resBody struct {
                Msg string `json:"message"`
        }
        request, err := httplib.Post(url).
                JSONBody(rasp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">response, err := request.Header("openrasp-token", token).
                SetTimeout(10*time.Second, 10*time.Second).
                Response()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if response.StatusCode != 200 </span><span class="cov0" title="0">{
                return errors.New("the status code is error: " + response.Status)
        }</span>
        <span class="cov8" title="1">err = request.ToJSON(&amp;resBody)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("response body is invalid: " + err.Error())
        }</span>
        <span class="cov8" title="1">if resBody.Msg != "ok" </span><span class="cov8" title="1">{
                return errors.New("the message of response body is not ok: " + resBody.Msg)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>

      <pre
        class="file"
        id="file33"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package models

import (
        "rasp-cloud/es"
        "time"
        "github.com/olivere/elastic"
        "context"
)

type ReportData struct {
        RaspId     string `json:"rasp_id"`
        Time       int64  `json:"time"`
        RequestSum int64  `json:"request_sum"`
        InsertTime int64  `json:"@timestamp"`
}

var (
        ReportIndexName      = "openrasp-report-data"
        AliasReportIndexName = "real-openrasp-report-data"
        reportType           = "report-data"
)

func init() <span class="cov8" title="1">{
        es.RegisterTTL(24*100*time.Hour, AliasReportIndexName+"-*")
}</span>

func CreateReportDataEsIndex(appId string) error <span class="cov8" title="1">{
        return es.CreateEsIndex(ReportIndexName + "-" + appId)
}</span>

func AddReportData(reportData *ReportData, appId string) error <span class="cov8" title="1">{
        reportData.InsertTime = time.Now().Unix() * 1000
        return es.Insert(AliasReportIndexName+"-"+appId, reportType, reportData)
}</span>

func GetHistoryRequestSum(startTime int64, endTime int64, interval string, timeZone string,
        appId string) (error, []map[string]interface{}) <span class="cov8" title="1">{
        ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
        defer cancel()
        timeAggrName := "aggr_time"
        sumAggrName := "request_sum"
        timeAggr := elastic.NewDateHistogramAggregation().Field("time").TimeZone(timeZone).
                Interval(interval).ExtendedBounds(startTime, endTime)
        requestSumAggr := elastic.NewSumAggregation().Field("request_sum")
        timeAggr.SubAggregation(sumAggrName, requestSumAggr)
        timeQuery := elastic.NewRangeQuery("time").Gte(startTime).Lte(endTime)
        aggrResult, err := es.ElasticClient.Search(AliasReportIndexName + "-" + appId).
                Query(timeQuery).
                Aggregation(timeAggrName, timeAggr).
                Size(0).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err, nil
        }</span>
        <span class="cov8" title="1">result := make([]map[string]interface{}, 0)
        if aggrResult != nil &amp;&amp; aggrResult.Aggregations != nil </span><span class="cov8" title="1">{
                if terms, ok := aggrResult.Aggregations.Terms(timeAggrName); ok &amp;&amp; terms.Buckets != nil </span><span class="cov8" title="1">{
                        result = make([]map[string]interface{}, len(terms.Buckets))
                        for index, item := range terms.Buckets </span><span class="cov8" title="1">{
                                result[index] = make(map[string]interface{})
                                result[index]["start_time"] = item.Key
                                if sumItem, ok := item.Sum(sumAggrName); ok </span><span class="cov8" title="1">{
                                        result[index]["request_sum"] = sumItem.Value
                                }</span> else<span class="cov0" title="0"> {
                                        result[index]["request_sum"] = 0
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil, result</span>
}
</pre>

      <pre
        class="file"
        id="file34"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package models

import "rasp-cloud/mongo"

const (
        serverUrlId               = "0"
        serverUrlCollectionName   = "server_url"
        serverAgentCollectionName = "server_agent"
)

type ServerUrl struct {
        PanelUrl  string   `json:"panel_url" bson:"panel_url"`
        AgentUrls []string `json:"agent_urls" bson:"agent_urls"`
}

func GetServerUrl() (serverUrl *ServerUrl, err error) <span class="cov8" title="1">{
        err = mongo.FindId(serverUrlCollectionName, serverUrlId, &amp;serverUrl)
        if err == nil &amp;&amp; serverUrl.AgentUrls == nil </span><span class="cov0" title="0">{
                serverUrl.AgentUrls = []string{}
        }</span>
        <span class="cov8" title="1">return</span>
}

func PutServerUrl(serverUrl *ServerUrl) (error) <span class="cov8" title="1">{
        return mongo.UpsertId(serverUrlCollectionName, serverUrlId, &amp;serverUrl)
}</span>
</pre>

      <pre
        class="file"
        id="file35"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package models

import (
        "rasp-cloud/mongo"
)

type Token struct {
        Token       string `json:"token" bson:"_id"`
        Description string `json:"description" bson:"description"`
}

const (
        tokenCollectionName = "token"
        AuthTokenName       = "X-OpenRASP-Token"
)

func GetAllToken(page int, perpage int) (count int, result []*Token, err error) <span class="cov8" title="1">{
        count, err = mongo.FindAll(tokenCollectionName, nil, &amp;result, perpage*(page-1), perpage)
        return
}</span>

func HasToken(token string) (bool, error) <span class="cov8" title="1">{
        var result *Token
        err := mongo.FindId(tokenCollectionName, token, &amp;result)
        if err != nil || result == nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">return true, err</span>
}

func AddToken(token *Token) (result *Token, err error) <span class="cov8" title="1">{
        if token.Token == "" </span><span class="cov8" title="1">{
                token.Token = generateOperationId()
        }</span>
        <span class="cov8" title="1">err = mongo.UpsertId(tokenCollectionName, token.Token, token)
        result = token
        return</span>
}

func RemoveToken(tokenId string) (token *Token, err error) <span class="cov8" title="1">{
        err = mongo.FindId(tokenCollectionName, tokenId, &amp;token)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return token, mongo.RemoveId(tokenCollectionName, tokenId)</span>
}
</pre>

      <pre
        class="file"
        id="file36"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package models

import (
        "github.com/astaxie/beego"
        "github.com/astaxie/beego/logs"
        "github.com/pkg/errors"
        "golang.org/x/crypto/bcrypt"
        "gopkg.in/mgo.v2"
        "gopkg.in/mgo.v2/bson"
        "os"
        "rasp-cloud/mongo"
        "rasp-cloud/tools"
        "regexp"
        "rasp-cloud/conf"
)

const (
        userCollectionName = "user"
        userName           = "openrasp"
)

type User struct {
        Id       string `bson:"_id"`
        Name     string `json:"name" bson:"name"`
        Password string `json:"password" bson:"password"`
}

var (
        userId string
)

func init() <span class="cov8" title="1">{
        count, err := mongo.Count(userCollectionName)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeMongoInitFailed, "failed to get the count of user collection", err)
        }</span>
        <span class="cov8" title="1">index := &amp;mgo.Index{
                Key:        []string{"name"},
                Unique:     true,
                Background: true,
                Name:       "name",
        }
        err = mongo.CreateIndex(userCollectionName, index)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeMongoInitFailed, "failed to create name index for user collection", err)
        }</span>
        <span class="cov8" title="1">if count &lt;= 0 </span><span class="cov0" title="0">{

                hash, err := generateHashedPassword("admin@123")
                if err != nil </span><span class="cov0" title="0">{
                        tools.Panic(tools.ErrCodeGeneratePasswdFailed, "failed to generate the default hashed password", err)
                }</span>
                <span class="cov0" title="0">userId = mongo.GenerateObjectId()
                user := User{
                        Id:       userId,
                        Name:     userName,
                        Password: hash,
                }
                err = mongo.Insert(userCollectionName, user)
                if err != nil </span><span class="cov0" title="0">{
                        tools.Panic(tools.ErrCodeMongoInitFailed, "failed to create default user", err)
                }</span>

        } else<span class="cov8" title="1"> {
                var user *User
                err = mongo.FindOne(userCollectionName, bson.M{}, &amp;user)
                if err != nil </span><span class="cov0" title="0">{
                        tools.Panic(tools.ErrCodeMongoInitFailed, "failed to get admin user", err)
                }</span>
                <span class="cov8" title="1">userId = user.Id</span>
        }

        <span class="cov8" title="1">if *conf.AppConfig.Flag.StartType == conf.StartTypeReset </span><span class="cov0" title="0">{
                if *conf.AppConfig.Flag.Password == "" </span><span class="cov0" title="0">{
                        tools.Panic(tools.ErrCodeResetUserFailed, "the password can not be empty", err)
                }</span>
                <span class="cov0" title="0">err := ResetUser(*conf.AppConfig.Flag.Password)
                if err != nil </span><span class="cov0" title="0">{
                        tools.Panic(tools.ErrCodeResetUserFailed, "failed to reset administrator", err)
                }</span>
                <span class="cov0" title="0">beego.Info("reset the administrator password successfully")
                os.Exit(0)</span>
        }
}

func ResetUser(newPwd string) error <span class="cov8" title="1">{
        err := validPassword(newPwd)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("invalid password: " + err.Error())
        }</span>
        <span class="cov8" title="1">pwd, err := generateHashedPassword(newPwd)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("failed to generate password: " + err.Error())
        }</span>
        <span class="cov8" title="1">err = mongo.UpdateId(userCollectionName, userId, bson.M{"password": pwd, "name": userName})
        return err</span>
}

func generateHashedPassword(password string) (string, error) <span class="cov8" title="1">{
        hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov8" title="1">{
                beego.Error("failed to generate hashed password: " + err.Error())
                return "", err
        }</span>
        <span class="cov8" title="1">return string(hash), nil</span>
}

func ComparePassword(hashedPassword string, password string) error <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
        if err != nil &amp;&amp; err != bcrypt.ErrMismatchedHashAndPassword </span><span class="cov8" title="1">{
                logs.Error("CompareHashAndPassword function error: " + err.Error())
        }</span>
        <span class="cov8" title="1">return err</span>
}

func validPassword(password string) error <span class="cov8" title="1">{
        hasNum := regexp.MustCompile(".*[0-9].*").Match([]byte(password))
        hasLetter := regexp.MustCompile(".*([a-z]|[A-Z]).*").Match([]byte(password))
        if len(password) &lt; 8 || len(password) &gt; 50 || !hasNum || !hasLetter </span><span class="cov8" title="1">{
                return errors.New("password must contain both letters and numbers, and the length of password must be between [8, 50]")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func GetLoginUserName() (userName string, err error) <span class="cov8" title="1">{
        var user *User
        err = mongo.FindId(userCollectionName, userId, &amp;user)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return user.Name, nil</span>
}

//func GetHashedLoginPassword() (pwd string, err error) {
//        var user *User
//        err = mongo.FindId(userCollectionName, userId, &amp;user)
//        if err != nil {
//                return
//        }
//        return user.Password, nil
//}

func VerifyUser(userName string, pwd string) error <span class="cov8" title="1">{
        var user *User
        err := mongo.FindId(userCollectionName, userId, &amp;user)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if userName != user.Name </span><span class="cov8" title="1">{
                return errors.New("username is incorrect")
        }</span>
        <span class="cov8" title="1">return ComparePassword(user.Password, pwd)</span>
}

func UpdatePassword(oldPwd string, newPwd string) error <span class="cov8" title="1">{
        err := VerifyUser(userName, oldPwd)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("old password is incorrect")
        }</span>
        <span class="cov8" title="1">err = validPassword(newPwd)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("Password does not meet complexity requirements: " + err.Error())
        }</span>
        <span class="cov8" title="1">pwd, err := generateHashedPassword(newPwd)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("failed to update new password")
        }</span>
        <span class="cov8" title="1">err = mongo.UpdateId(userCollectionName, userId, bson.M{"password": pwd})
        return err</span>
}
</pre>

      <pre
        class="file"
        id="file37"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package mongo

import (
        "gopkg.in/mgo.v2"
        "time"
        "github.com/astaxie/beego"
        "rasp-cloud/tools"
        "gopkg.in/mgo.v2/bson"
        "strconv"
        "math/rand"
        "fmt"
        "crypto/sha1"
        "strings"
        "rasp-cloud/conf"
)

var (
        minMongoVersion = "3.6.0"
        session         *mgo.Session
        DbName          = conf.AppConfig.MongoDBName
)

func init() <span class="cov8" title="1">{
        var err error
        dialInfo := &amp;mgo.DialInfo{
                Addrs:     []string{conf.AppConfig.MongoDBAddr},
                Username:  conf.AppConfig.MongoDBUser,
                Password:  conf.AppConfig.MongoDBPwd,
                Direct:    false,
                Timeout:   time.Second * 20,
                FailFast:  true,
                PoolLimit: conf.AppConfig.MongoDBPoolLimit,
                Database:  DbName,
        }
        session, err = mgo.DialWithInfo(dialInfo)
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeMongoInitFailed, "failed to find MongoDB server: ", err)
        }</span>
        <span class="cov8" title="1">info, err := session.BuildInfo()
        if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeMongoInitFailed, "failed to get MongoDB version", err)
        }</span>
        <span class="cov8" title="1">beego.Info("MongoDB version: " + info.Version)
        if strings.Compare(info.Version, minMongoVersion) &lt; 0 </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeMongoInitFailed, "unable to support the MongoDB with a version lower than "+
                        minMongoVersion+ ","+ " the current version is "+ info.Version, nil)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                tools.Panic(tools.ErrCodeMongoInitFailed, "init MongoDB failed", err)
        }</span>

        <span class="cov8" title="1">session.SetMode(mgo.Strong, true)</span>
}

func NewSession() *mgo.Session <span class="cov8" title="1">{
        return session.Copy()
}</span>

func Count(collection string) (int, error) <span class="cov8" title="1">{
        newSession := NewSession()
        defer newSession.Close()
        return newSession.DB(DbName).C(collection).Count()
}</span>

func CreateIndex(collection string, index *mgo.Index) error <span class="cov8" title="1">{
        newSession := NewSession()
        defer newSession.Close()
        return newSession.DB(DbName).C(collection).EnsureIndex(*index)
}</span>

func Insert(collection string, doc interface{}) error <span class="cov8" title="1">{
        newSession := NewSession()
        defer newSession.Close()
        return newSession.DB(DbName).C(collection).Insert(doc)
}</span>

func UpsertId(collection string, id interface{}, doc interface{}) error <span class="cov8" title="1">{
        newSession := NewSession()
        defer newSession.Close()
        _, err := newSession.DB(DbName).C(collection).UpsertId(id, doc)
        return err
}</span>

func FindAll(collection string, query interface{}, result interface{}, skip int, limit int,
        sortFields ...string) (count int, err error) <span class="cov8" title="1">{
        newSession := NewSession()
        defer newSession.Close()
        count, err = newSession.DB(DbName).C(collection).Find(query).Count()
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">err = newSession.DB(DbName).C(collection).Find(query).Skip(skip).Limit(limit).Sort(sortFields...).All(result)
        return</span>
}

func FindAllWithoutLimit(collection string, query interface{}, result interface{},
        sortFields ...string) (count int, err error) <span class="cov8" title="1">{
        newSession := NewSession()
        defer newSession.Close()
        count, err = newSession.DB(DbName).C(collection).Find(query).Count()
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">err = newSession.DB(DbName).C(collection).Find(query).Sort(sortFields...).All(result)
        return</span>
}

func FindAllWithSelect(collection string, query interface{}, result interface{}, selector interface{},
        skip int, limit int) (count int, err error) <span class="cov8" title="1">{
        newSession := NewSession()
        defer newSession.Close()
        count, err = newSession.DB(DbName).C(collection).Find(query).Count()
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">err = newSession.DB(DbName).C(collection).Find(query).Select(selector).Skip(skip).Limit(limit).All(result)
        return</span>
}

func FindId(collection string, id string, result interface{}) error <span class="cov8" title="1">{
        newSession := NewSession()
        defer newSession.Close()
        return newSession.DB(DbName).C(collection).FindId(id).One(result)
}</span>

func FindOne(collection string, query interface{}, result interface{}) error <span class="cov8" title="1">{
        newSession := NewSession()
        defer newSession.Close()
        return newSession.DB(DbName).C(collection).Find(query).One(result)
}</span>

func FindAllBySort(collection string, query interface{}, skip int, limit int, result interface{},
        sortFields ...string) (count int, err error) <span class="cov8" title="1">{
        newSession := NewSession()
        defer newSession.Close()
        count, err = newSession.DB(DbName).C(collection).Find(query).Count()
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">return count, newSession.DB(DbName).C(collection).Find(query).Sort(sortFields...).Skip(skip).Limit(limit).All(result)</span>
}

func UpdateId(collection string, id interface{}, doc interface{}) error <span class="cov8" title="1">{
        newSession := NewSession()
        defer newSession.Close()
        return newSession.DB(DbName).C(collection).UpdateId(id, bson.M{"$set": doc})
}</span>

func RemoveId(collection string, id interface{}) error <span class="cov8" title="1">{
        newSession := NewSession()
        defer newSession.Close()
        return newSession.DB(DbName).C(collection).RemoveId(id)
}</span>

func RemoveAll(collection string, selector interface{}) (*mgo.ChangeInfo, error) <span class="cov8" title="1">{
        newSession := NewSession()
        defer newSession.Close()
        return newSession.DB(DbName).C(collection).RemoveAll(selector)
}</span>

func GenerateObjectId() string <span class="cov8" title="1">{
        random := string(bson.NewObjectId()) +
                strconv.FormatInt(time.Now().UnixNano(), 10) + strconv.Itoa(rand.Intn(10000))
        return fmt.Sprintf("%x", sha1.Sum([]byte(random)))
}</span>
</pre>

      <pre class="file" id="file38" style="display: none">package routers

import (
        "github.com/astaxie/beego"
        "github.com/astaxie/beego/context/param"
)

func init() <span class="cov8" title="1">{

    beego.GlobalControllerRouter["rasp-cloud/controllers:PingController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers:PingController"],
        beego.ControllerComments{
            Method: "Ping",
            Router: `/`,
            AllowHTTPMethods: []string{"get","post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

}</span>
</pre>

      <pre class="file" id="file39" style="display: none">package routers

import (
        "github.com/astaxie/beego"
        "github.com/astaxie/beego/context/param"
)

func init() <span class="cov8" title="1">{

    beego.GlobalControllerRouter["rasp-cloud/controllers/agent:HeartbeatController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/agent:HeartbeatController"],
        beego.ControllerComments{
            Method: "Post",
            Router: `/`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/agent:RaspController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/agent:RaspController"],
        beego.ControllerComments{
            Method: "Post",
            Router: `/`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/agent:ReportController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/agent:ReportController"],
        beego.ControllerComments{
            Method: "Post",
            Router: `/`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

}</span>
</pre>

      <pre class="file" id="file40" style="display: none">package routers

import (
        "github.com/astaxie/beego"
        "github.com/astaxie/beego/context/param"
)

func init() <span class="cov8" title="1">{

    beego.GlobalControllerRouter["rasp-cloud/controllers/agent/agent_logs:AttackAlarmController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/agent/agent_logs:AttackAlarmController"],
        beego.ControllerComments{
            Method: "Post",
            Router: `/`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/agent/agent_logs:ErrorController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/agent/agent_logs:ErrorController"],
        beego.ControllerComments{
            Method: "Post",
            Router: `/`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/agent/agent_logs:PolicyAlarmController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/agent/agent_logs:PolicyAlarmController"],
        beego.ControllerComments{
            Method: "Post",
            Router: `/`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

}</span>
</pre>

      <pre class="file" id="file41" style="display: none">package routers

import (
        "github.com/astaxie/beego"
        "github.com/astaxie/beego/context/param"
)

func init() <span class="cov8" title="1">{

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "Post",
            Router: `/`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "ConfigAlarm",
            Router: `/alarm/config`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "ConfigApp",
            Router: `/config`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "Delete",
            Router: `/delete`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "TestDing",
            Router: `/ding/test`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(
                                param.New("config"),
                        ),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "TestEmail",
            Router: `/email/test`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "UpdateAppGeneralConfig",
            Router: `/general/config`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "GetApp",
            Router: `/get`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "TestHttp",
            Router: `/http/test`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(
                                param.New("config"),
                        ),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "GetPlugins",
            Router: `/plugin/get`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "SetSelectedPlugin",
            Router: `/plugin/select`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "GetSelectedPlugin",
            Router: `/plugin/select/get`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "GetRasps",
            Router: `/rasp/get`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "GetAppSecret",
            Router: `/secret/get`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "RegenerateAppSecret",
            Router: `/secret/regenerate`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:AppController"],
        beego.ControllerComments{
            Method: "UpdateAppWhiteListConfig",
            Router: `/whitelist/config`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:OperationController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:OperationController"],
        beego.ControllerComments{
            Method: "Search",
            Router: `/search`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:PluginController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:PluginController"],
        beego.ControllerComments{
            Method: "Upload",
            Router: `/`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:PluginController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:PluginController"],
        beego.ControllerComments{
            Method: "UpdateAppAlgorithmConfig",
            Router: `/algorithm/config`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:PluginController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:PluginController"],
        beego.ControllerComments{
            Method: "RestoreAlgorithmConfig",
            Router: `/algorithm/restore`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:PluginController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:PluginController"],
        beego.ControllerComments{
            Method: "Delete",
            Router: `/delete`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:PluginController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:PluginController"],
        beego.ControllerComments{
            Method: "Download",
            Router: `/download`,
            AllowHTTPMethods: []string{"get"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:PluginController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:PluginController"],
        beego.ControllerComments{
            Method: "Get",
            Router: `/get`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:RaspController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:RaspController"],
        beego.ControllerComments{
            Method: "Delete",
            Router: `/delete`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:RaspController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:RaspController"],
        beego.ControllerComments{
            Method: "Search",
            Router: `/search`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:ReportController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:ReportController"],
        beego.ControllerComments{
            Method: "Search",
            Router: `/dashboard`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:ServerController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:ServerController"],
        beego.ControllerComments{
            Method: "PutUrl",
            Router: `/url`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:ServerController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:ServerController"],
        beego.ControllerComments{
            Method: "GetUrl",
            Router: `/url/get`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:TokenController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:TokenController"],
        beego.ControllerComments{
            Method: "Post",
            Router: `/`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:TokenController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:TokenController"],
        beego.ControllerComments{
            Method: "Delete",
            Router: `/delete`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:TokenController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:TokenController"],
        beego.ControllerComments{
            Method: "Get",
            Router: `/get`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:UserController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:UserController"],
        beego.ControllerComments{
            Method: "IsLogin",
            Router: `/islogin`,
            AllowHTTPMethods: []string{"get","post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:UserController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:UserController"],
        beego.ControllerComments{
            Method: "Login",
            Router: `/login`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:UserController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:UserController"],
        beego.ControllerComments{
            Method: "Logout",
            Router: `/logout`,
            AllowHTTPMethods: []string{"get","post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api:UserController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api:UserController"],
        beego.ControllerComments{
            Method: "Update",
            Router: `/update`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

}</span>
</pre>

      <pre class="file" id="file42" style="display: none">package routers

import (
        "github.com/astaxie/beego"
        "github.com/astaxie/beego/context/param"
)

func init() <span class="cov8" title="1">{

    beego.GlobalControllerRouter["rasp-cloud/controllers/api/fore_logs:AttackAlarmController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api/fore_logs:AttackAlarmController"],
        beego.ControllerComments{
            Method: "AggregationWithTime",
            Router: `/aggr/time`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api/fore_logs:AttackAlarmController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api/fore_logs:AttackAlarmController"],
        beego.ControllerComments{
            Method: "AggregationWithType",
            Router: `/aggr/type`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api/fore_logs:AttackAlarmController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api/fore_logs:AttackAlarmController"],
        beego.ControllerComments{
            Method: "AggregationWithUserAgent",
            Router: `/aggr/ua`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api/fore_logs:AttackAlarmController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api/fore_logs:AttackAlarmController"],
        beego.ControllerComments{
            Method: "AggregationVuln",
            Router: `/aggr/vuln`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api/fore_logs:AttackAlarmController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api/fore_logs:AttackAlarmController"],
        beego.ControllerComments{
            Method: "Search",
            Router: `/search`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api/fore_logs:ErrorController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api/fore_logs:ErrorController"],
        beego.ControllerComments{
            Method: "Search",
            Router: `/search`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["rasp-cloud/controllers/api/fore_logs:PolicyAlarmController"] = append(beego.GlobalControllerRouter["rasp-cloud/controllers/api/fore_logs:PolicyAlarmController"],
        beego.ControllerComments{
            Method: "Search",
            Router: `/search`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

}</span>
</pre>

      <pre
        class="file"
        id="file43"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package routers

import (
        "github.com/astaxie/beego"
        "rasp-cloud/controllers/agent"
        "rasp-cloud/controllers/agent/agent_logs"
        "rasp-cloud/controllers/api"
        "rasp-cloud/controllers/api/fore_logs"
        "rasp-cloud/tools"
        "rasp-cloud/conf"
        "rasp-cloud/controllers"
)

func InitRouter() <span class="cov8" title="1">{
        agentNS := beego.NewNamespace("/agent",
                beego.NSNamespace("/heartbeat",
                        beego.NSInclude(
                                &amp;agent.HeartbeatController{},
                        ),
                ),
                beego.NSNamespace("/log",
                        beego.NSNamespace("/attack",
                                beego.NSInclude(
                                        &amp;agent_logs.AttackAlarmController{},
                                ),
                        ),
                        beego.NSNamespace("/policy",
                                beego.NSInclude(
                                        &amp;agent_logs.PolicyAlarmController{},
                                ),
                        ),
                        beego.NSNamespace("/error",
                                beego.NSInclude(
                                        &amp;agent_logs.ErrorController{},
                                ),
                        ),
                ),
                beego.NSNamespace("/rasp",
                        beego.NSInclude(
                                &amp;agent.RaspController{},
                        ),
                ),
                beego.NSNamespace("/report",
                        beego.NSInclude(
                                &amp;agent.ReportController{},
                        ),
                ),
        )
        foregroudNS := beego.NewNamespace("/api",

                beego.NSNamespace("/plugin",
                        beego.NSInclude(
                                &amp;api.PluginController{},
                        ),
                ),
                beego.NSNamespace("/log",
                        beego.NSNamespace("/attack",
                                beego.NSInclude(
                                        &amp;fore_logs.AttackAlarmController{},
                                ),
                        ),
                        beego.NSNamespace("/policy",
                                beego.NSInclude(
                                        &amp;fore_logs.PolicyAlarmController{},
                                ),
                        ),
                        beego.NSNamespace("/error",
                                beego.NSInclude(
                                        &amp;fore_logs.ErrorController{},
                                ),
                        ),
                ),
                beego.NSNamespace("/app",
                        beego.NSInclude(
                                &amp;api.AppController{},
                        ),
                ),
                beego.NSNamespace("/rasp",
                        beego.NSInclude(
                                &amp;api.RaspController{},
                        ),
                ),
                beego.NSNamespace("/token",
                        beego.NSInclude(
                                &amp;api.TokenController{},
                        ),
                ),
                beego.NSNamespace("/report",
                        beego.NSInclude(
                                &amp;api.ReportController{},
                        ),
                ),
                beego.NSNamespace("/operation",
                        beego.NSInclude(
                                &amp;api.OperationController{},
                        ),
                ),
                beego.NSNamespace("/server",
                        beego.NSInclude(
                                &amp;api.ServerController{},
                        ),
                ),
        )
        userNS := beego.NewNamespace("/user", beego.NSInclude(&amp;api.UserController{}))
        pingNS := beego.NewNamespace("/ping", beego.NSInclude(&amp;controllers.PingController{}))
        ns := beego.NewNamespace("/v1")
        ns.Namespace(pingNS)
        startType := *conf.AppConfig.Flag.StartType
        if startType == conf.StartTypeForeground </span><span class="cov0" title="0">{
                ns.Namespace(foregroudNS, userNS)
        }</span> else<span class="cov8" title="1"> if startType == conf.StartTypeAgent </span><span class="cov0" title="0">{
                ns.Namespace(agentNS)
        }</span> else<span class="cov8" title="1"> if startType == conf.StartTypeDefault </span><span class="cov8" title="1">{
                ns.Namespace(foregroudNS, agentNS, userNS)
        }</span> else<span class="cov0" title="0"> {
                tools.Panic(tools.ErrCodeStartTypeNotSupport, "The start type is not supported: "+startType, nil)
        }</span>
        <span class="cov8" title="1">if startType == conf.StartTypeForeground || startType == conf.StartTypeDefault </span><span class="cov8" title="1">{
                beego.SetStaticPath("//", tools.GetCurrentPathWithPanic()+"/dist")
        }</span>
        <span class="cov8" title="1">beego.AddNamespace(ns)</span>
}
</pre>

      <pre class="file" id="file44" style="display: none">package inits

import (
        "fmt"
        "path/filepath"
        "rasp-cloud/tools"
        "github.com/bouk/monkey"
        "bytes"
        "net/http/httptest"
        "github.com/astaxie/beego"
        "net/http"
        "encoding/json"
        . "github.com/smartystreets/goconvey/convey"
)

type Response struct {
        Status int         `json:"status"`
        Desc   string      `json:"description"`
        Data   interface{} `json:"data"`
}

func init() <span class="cov8" title="1">{
        tools.GetCurrentPath()
        tools.PathExists("/xxx/xxx/xxxxxxx")
        apppath, _ := filepath.Abs(filepath.Dir("./"))
        monkey.Patch(tools.GetCurrentPath, func() (string, error) </span><span class="cov8" title="1">{
                return apppath, nil
        }</span>)
        <span class="cov8" title="1">fmt.Println(tools.GetCurrentPath())</span>
}

func GetResponse(method string, path string, body string) (*Response) <span class="cov8" title="1">{
        r, _ := http.NewRequest(method, path, bytes.NewBuffer([]byte(body)))
        w := httptest.NewRecorder()
        beego.BeeApp.Handlers.ServeHTTP(w, r)
        response := &amp;Response{}
        So(w.Code, ShouldEqual, 200)
        err := json.Unmarshal(w.Body.Bytes(), response)
        So(err, ShouldEqual, nil)
        return response
}</span>

func GetResponseRecorder(method string, path string, body string) (*httptest.ResponseRecorder) <span class="cov8" title="1">{
        r, _ := http.NewRequest(method, path, bytes.NewBuffer([]byte(body)))
        w := httptest.NewRecorder()
        beego.BeeApp.Handlers.ServeHTTP(w, r)
        return w
}</span>

func GetJson(data interface{}) string <span class="cov8" title="1">{
        jsonBytes, _ := json.Marshal(data)
        return string(jsonBytes)
}</span>

func GetLongString(length int) string <span class="cov8" title="1">{
        result := ""
        for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                result += "a"
        }</span>
        <span class="cov8" title="1">return result</span>
}

func GetLongStringArray(length int) []string <span class="cov8" title="1">{
        result := make([]string, length)
        for i := 0; i &lt; length; i++ </span><span class="cov8" title="1">{
                result[i] = "a"
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>

      <pre class="file" id="file45" style="display: none">package start

import (
        _ "rasp-cloud/tests/inits"
        _ "rasp-cloud/environment"
        _ "rasp-cloud/models"
        //_ "rasp-cloud/filter"
        _ "rasp-cloud/controllers"
        "rasp-cloud/routers"
        "github.com/astaxie/beego"
        "rasp-cloud/controllers"
        "github.com/astaxie/beego/context"
        "rasp-cloud/models"
)

var TestApp = &amp;models.App{
        Name:        "test_app",
        Language:    "java",
        Description: "test app",
}
var online = false
var TestRasp = &amp;models.Rasp{
        Id:                "1234567890abc121321354545135135",
        Language:          "java",
        Version:           "1.0",
        HostName:          "ubuntu",
        RegisterIp:        "10.23.25.36",
        LanguageVersion:   "1.8",
        ServerType:        "tomcat",
        RaspHome:          "/home/work/tomcat8",
        PluginVersion:     "2019-03-10-10000",
        HeartbeatInterval: 180,
        LastHeartbeatTime: 1551781949000,
        RegisterTime:      1551781949000,
        Environ:           map[string]string{},
        Online:            &amp;online,
}

func init() <span class="cov8" title="1">{
        routers.InitRouter()
        beego.ErrorController(&amp;controllers.ErrorController{})
        beego.BConfig.RecoverFunc = func(*context.Context) </span><span class="cov8" title="1">{
                if err := recover(); err != nil </span>{<span class="cov8" title="1">
                }</span>
        }
        <span class="cov8" title="1">count, apps, _ := models.GetAllApp(1, 1, false)
        if count &gt; 0 </span><span class="cov8" title="1">{
                TestApp = apps[0]
        }</span> else<span class="cov0" title="0"> {
                TestApp, _ = models.AddApp(TestApp)
        }</span>
        <span class="cov8" title="1">TestRasp.AppId = TestApp.Id
        models.UpsertRaspById(TestRasp.Id, TestRasp)</span>
}
</pre>

      <pre class="file" id="file46" style="display: none">package tools

import "net/smtp"

type loginAuth struct {
        username, password string
}

func LoginAuth(username, password string) smtp.Auth <span class="cov8" title="1">{
        return &amp;loginAuth{username, password}
}</span>

func (auth *loginAuth) Start(server *smtp.ServerInfo) (string, []byte, error) <span class="cov0" title="0">{
        return "LOGIN", []byte(auth.username), nil
}</span>

func (auth *loginAuth) Next(fromServer []byte, more bool) ([]byte, error) <span class="cov0" title="0">{
        if more </span><span class="cov0" title="0">{
                switch string(fromServer) </span>{
                case "Username:":<span class="cov0" title="0">
                        return []byte(auth.username), nil</span>
                case "Password:":<span class="cov0" title="0">
                        return []byte(auth.password), nil</span>
                }
        }
        <span class="cov0" title="0">return nil, nil</span>
}
</pre>

      <pre
        class="file"
        id="file47"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package tools

import (
        "github.com/astaxie/beego/logs"
        "strconv"
        "os"
)

const (
        ErrCodeLogInitFailed          = 30001 + iota
        ErrCodeMongoInitFailed
        ErrCodeESInitFailed
        ErrCodeConfigInitFailed
        ErrCodeStartTypeNotSupport
        ErrCodeGeneratePasswdFailed
        ErrCodeGeoipInit
        ErrCodeResetUserFailed
        ErrCodeInitDefaultAppFailed
        ErrCodeInitChildProcessFailed
)

func Panic(errCode int, message string, err error) <span class="cov8" title="1">{
        message = "[" + strconv.Itoa(errCode) + "] " + message
        if err != nil </span><span class="cov8" title="1">{
                message = message + ": " + err.Error()
        }</span>
        <span class="cov8" title="1">logs.Error(message)
        os.Exit(errCode)</span>
}
</pre>

      <pre
        class="file"
        id="file48"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package tools

import (
        "os"
        "strings"
        "path/filepath"
        "os/exec"
        "errors"
)

func GetCurrentPathWithPanic() string <span class="cov8" title="1">{
        currentPath, err := GetCurrentPath()
        if err != nil </span><span class="cov0" title="0">{
                Panic(ErrCodeLogInitFailed, "failed to get current path", err)
        }</span>
        <span class="cov8" title="1">return currentPath</span>
}

func GetCurrentPath() (string, error) <span class="cov8" title="1">{
        file, err := exec.LookPath(os.Args[0])
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">path, err := filepath.Abs(file)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">i := strings.LastIndex(path, "/")
        if i &lt; 0 </span><span class="cov0" title="0">{
                i = strings.LastIndex(path, "\\")
        }</span>
        <span class="cov8" title="1">if i &lt; 0 </span><span class="cov0" title="0">{
                return "", errors.New(`error: Can't find "/" or "\"`)
        }</span>
        <span class="cov8" title="1">return string(path[0 : i+1]), nil</span>
}

func PathExists(path string) (bool, error) <span class="cov8" title="1">{
        _, err := os.Stat(path)
        if err == nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return false, err</span>
}
</pre>

      <pre
        class="file"
        id="file49"
        style="display: none"
      >//Copyright 2017-2020 Baidu Inc.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http: //www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

package tools

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path"
        "path/filepath"
        "strconv"
        "strings"
        "sync"
        "time"
        "github.com/astaxie/beego/logs"
)

var (
        AdapterAlarmFile = "alarm_file_logger "
)

// RaspFileLogWriter implements LoggerInterface.
// It writes messages by lines limit, file size limit, or time frequency.
type RaspFileLogWriter struct {
        sync.RWMutex // write log order by order and  atomic incr maxLinesCurLines and maxSizeCurSize
        // The opened file
        Filename   string `json:"filename"`
        fileWriter *os.File

        // Rotate at line
        MaxLines         int `json:"maxlines"`
        maxLinesCurLines int

        MaxFiles         int `json:"maxfiles"`
        MaxFilesCurFiles int

        // Rotate at size
        MaxSize        int `json:"maxsize"`
        maxSizeCurSize int

        // Rotate daily
        Daily         bool  `json:"daily"`
        MaxDays       int64 `json:"maxdays"`
        dailyOpenDate int
        dailyOpenTime time.Time

        Rotate bool `json:"rotate"`

        Level int `json:"level"`

        Perm string `json:"perm"`

        RotatePerm string `json:"rotateperm"`

        fileNameOnly, suffix string // like "project.log", project is fileNameOnly and .log is suffix
}

// newFileWriter create a FileLogWriter returning as LoggerInterface.
func NewFileWriter() logs.Logger <span class="cov8" title="1">{
        w := &amp;RaspFileLogWriter{
                Daily:      true,
                MaxDays:    7,
                Rotate:     true,
                RotatePerm: "0440",
                Level:      logs.LevelTrace,
                Perm:       "0660",
                MaxLines:   10000000,
                MaxFiles:   999,
                MaxSize:    1 &lt;&lt; 28,
        }
        return w
}</span>

// Init file logger with json config.
// jsonConfig like:
//        {
//        "filename":"logs/beego.log",
//        "maxLines":10000,
//        "maxsize":1024,
//        "daily":true,
//        "maxDays":15,
//        "rotate":true,
//          "perm":"0600"
//        }
func (w *RaspFileLogWriter) Init(jsonConfig string) error <span class="cov8" title="1">{
        err := json.Unmarshal([]byte(jsonConfig), w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(w.Filename) == 0 </span><span class="cov0" title="0">{
                return errors.New("jsonconfig must have filename")
        }</span>
        <span class="cov8" title="1">w.suffix = filepath.Ext(w.Filename)
        w.fileNameOnly = strings.TrimSuffix(w.Filename, w.suffix)
        if w.suffix == "" </span><span class="cov0" title="0">{
                w.suffix = ".log"
        }</span>
        <span class="cov8" title="1">err = w.startLogger()
        return err</span>
}

// start file logger. create log file and set to locker-inside file writer.
func (w *RaspFileLogWriter) startLogger() error <span class="cov8" title="1">{
        file, err := w.createLogFile()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if w.fileWriter != nil </span><span class="cov0" title="0">{
                w.fileWriter.Close()
        }</span>
        <span class="cov8" title="1">w.fileWriter = file
        return w.initFd()</span>
}

func (w *RaspFileLogWriter) NeedRotate(size int, day int) bool <span class="cov8" title="1">{
        return (w.MaxLines &gt; 0 &amp;&amp; w.maxLinesCurLines &gt;= w.MaxLines) ||
                (w.MaxSize &gt; 0 &amp;&amp; w.maxSizeCurSize &gt;= w.MaxSize) ||
                (w.Daily &amp;&amp; day != w.dailyOpenDate)

}</span>

// WriteMsg write logger message into file.
func (w *RaspFileLogWriter) WriteMsg(when time.Time, msg string, level int) error <span class="cov8" title="1">{
        if level &gt; w.Level </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">_, _, d := when.Date()
        msg = msg + "\n"
        if w.Rotate </span><span class="cov8" title="1">{
                w.RLock()
                if w.NeedRotate(len(msg), d) </span><span class="cov0" title="0">{
                        w.RUnlock()
                        w.Lock()
                        if w.NeedRotate(len(msg), d) </span><span class="cov0" title="0">{
                                if err := w.DoRotate(when); err != nil </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "FileLogWriter(%q): %s\n", w.Filename, err)
                                }</span>
                        }
                        <span class="cov0" title="0">w.Unlock()</span>
                } else<span class="cov8" title="1"> {
                        w.RUnlock()
                }</span>
        }

        <span class="cov8" title="1">w.Lock()
        _, err := w.fileWriter.Write([]byte(msg))
        if err == nil </span><span class="cov8" title="1">{
                w.maxLinesCurLines++
                w.maxSizeCurSize += len(msg)
        }</span>
        <span class="cov8" title="1">w.Unlock()
        return err</span>
}

func (w *RaspFileLogWriter) createLogFile() (*os.File, error) <span class="cov8" title="1">{
        // Open the log file
        perm, err := strconv.ParseInt(w.Perm, 8, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">filepath := path.Dir(w.Filename)
        os.MkdirAll(filepath, os.FileMode(perm))

        fd, err := os.OpenFile(w.Filename, os.O_WRONLY|os.O_APPEND|os.O_CREATE, os.FileMode(perm))
        if err == nil </span><span class="cov8" title="1">{
                // Make sure file perm is user set perm cause of `os.OpenFile` will obey umask
                os.Chmod(w.Filename, os.FileMode(perm))
        }</span>
        <span class="cov8" title="1">return fd, err</span>
}

func (w *RaspFileLogWriter) initFd() error <span class="cov8" title="1">{
        fd := w.fileWriter
        fInfo, err := fd.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get stat err: %s", err)
        }</span>
        <span class="cov8" title="1">w.maxSizeCurSize = int(fInfo.Size())
        w.dailyOpenTime = time.Now()
        w.dailyOpenDate = w.dailyOpenTime.Day()
        w.maxLinesCurLines = 0
        if w.Daily </span><span class="cov8" title="1">{
                go w.dailyRotate(w.dailyOpenTime)
        }</span>
        <span class="cov8" title="1">if fInfo.Size() &gt; 0 &amp;&amp; w.MaxLines &gt; 0 </span><span class="cov8" title="1">{
                count, err := w.lines()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">w.maxLinesCurLines = count</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (w *RaspFileLogWriter) dailyRotate(openTime time.Time) <span class="cov8" title="1">{
        y, m, d := openTime.Add(24 * time.Hour).Date()
        nextDay := time.Date(y, m, d, 0, 0, 0, 0, openTime.Location())
        tm := time.NewTimer(time.Duration(nextDay.UnixNano() - openTime.UnixNano() + 100))
        &lt;-tm.C
        w.Lock()
        if w.NeedRotate(0, time.Now().Day()) </span><span class="cov0" title="0">{
                if err := w.DoRotate(time.Now()); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "FileLogWriter(%q): %s\n", w.Filename, err)
                }</span>
        }
        <span class="cov0" title="0">w.Unlock()</span>
}

func (w *RaspFileLogWriter) lines() (int, error) <span class="cov8" title="1">{
        fd, err := os.Open(w.Filename)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">defer fd.Close()

        buf := make([]byte, 32768) // 32k
        count := 0
        lineSep := []byte{'\n'}

        for </span><span class="cov8" title="1">{
                c, err := fd.Read(buf)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return count, err
                }</span>

                <span class="cov8" title="1">count += bytes.Count(buf[:c], lineSep)

                if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return count, nil</span>
}

// DoRotate means it need to write file in new file.
// new file name like xx.2013-01-01.log (daily) or xx.001.log (by line or size)
func (w *RaspFileLogWriter) DoRotate(logTime time.Time) error <span class="cov8" title="1">{
        // file exists
        // Find the next available number
        num := w.MaxFilesCurFiles + 1
        fName := ""
        rotatePerm, err := strconv.ParseInt(w.RotatePerm, 8, 64)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">_, err = os.Lstat(w.Filename)
        if err != nil </span><span class="cov0" title="0">{
                //even if the file is not exist or other ,we should RESTART the logger
                goto RESTART_LOGGER</span>
        }

        // only when one of them be setted, then the file would be splited
        <span class="cov8" title="1">if w.MaxLines &gt; 0 || w.MaxSize &gt; 0 </span><span class="cov8" title="1">{
                for ; err == nil &amp;&amp; num &lt;= w.MaxFiles; num++ </span><span class="cov8" title="1">{
                        fName = w.fileNameOnly + fmt.Sprintf(".%s.%03d%s", logTime.Format("2006-01-02"), num, w.suffix)
                        _, err = os.Lstat(fName)
                }</span>
        } else<span class="cov8" title="1"> {
                fName = w.fileNameOnly + fmt.Sprintf(".%s.%03d%s", w.dailyOpenTime.Format("2006-01-02"), num, w.suffix)
                _, err = os.Lstat(fName)
                w.MaxFilesCurFiles = num
        }</span>
        // return error if the last file checked still existed
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("Rotate: Cannot find free log number to rename %s", w.Filename)
        }</span>

        // close fileWriter before rename
        <span class="cov8" title="1">w.fileWriter.Close()

        // Rename the file to its new found name
        // even if occurs error,we MUST guarantee to  restart new logger
        err = os.Rename(w.Filename, fName)
        if err != nil </span><span class="cov0" title="0">{
                goto RESTART_LOGGER</span>
        }

        <span class="cov8" title="1">err = os.Chmod(fName, os.FileMode(rotatePerm))

</span>RESTART_LOGGER:

        <span class="cov8" title="1">startLoggerErr := w.startLogger()
        go w.deleteOldLog()

        if startLoggerErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Rotate StartLogger: %s", startLoggerErr)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Rotate: %s", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (w *RaspFileLogWriter) deleteOldLog() <span class="cov8" title="1">{
        dir := filepath.Dir(w.Filename)
        filepath.Walk(dir, func(path string, info os.FileInfo, err error) (returnErr error) </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Unable to delete old log '%s', error: %v\n", path, r)
                        }</span>
                }()

                <span class="cov8" title="1">if info == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">if !info.IsDir() &amp;&amp; info.ModTime().Add(24 * time.Hour * time.Duration(w.MaxDays)).Before(time.Now()) </span><span class="cov0" title="0">{
                        if strings.HasPrefix(filepath.Base(path), filepath.Base(w.fileNameOnly)) &amp;&amp;
                                strings.HasSuffix(filepath.Base(path), w.suffix) </span><span class="cov0" title="0">{
                                os.Remove(path)
                        }</span>
                }
                <span class="cov8" title="1">return</span>
        })
}

// Destroy close the file description, close file writer.
func (w *RaspFileLogWriter) Destroy() <span class="cov0" title="0">{
        w.fileWriter.Close()
}</span>

// Flush flush file logger.
// there are no buffering messages in file logger in memory.
// flush file means sync file from disk.
func (w *RaspFileLogWriter) Flush() <span class="cov0" title="0">{
        w.fileWriter.Sync()
}</span>

func init() <span class="cov8" title="1">{
        logs.Register(AdapterAlarmFile, NewFileWriter)
}</span>
</pre>
    </div>
  </body>
  <script>
    (function () {
      var files = document.getElementById("files");
      var visible;
      files.addEventListener("change", onChange, false);
      function select(part) {
        if (visible) visible.style.display = "none";
        visible = document.getElementById(part);
        if (!visible) return;
        files.value = part;
        visible.style.display = "block";
        location.hash = part;
      }
      function onChange() {
        select(files.value);
        window.scrollTo(0, 0);
      }
      if (location.hash != "") {
        select(location.hash.substr(1));
      }
      if (!visible) {
        select("file0");
      }
    })();
  </script>
</html>
